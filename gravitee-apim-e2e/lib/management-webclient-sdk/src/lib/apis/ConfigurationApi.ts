/* tslint:disable */
/* eslint-disable */
/**
 * Gravitee.io - Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ApiHeaderEntity,
    ApiHeaderEntityFromJSON,
    ApiHeaderEntityToJSON,
    CategoryEntity,
    CategoryEntityFromJSON,
    CategoryEntityToJSON,
    ClientRegistrationProviderEntity,
    ClientRegistrationProviderEntityFromJSON,
    ClientRegistrationProviderEntityToJSON,
    ClientRegistrationProviderListItem,
    ClientRegistrationProviderListItemFromJSON,
    ClientRegistrationProviderListItemToJSON,
    CustomUserFieldEntity,
    CustomUserFieldEntityFromJSON,
    CustomUserFieldEntityToJSON,
    DashboardEntity,
    DashboardEntityFromJSON,
    DashboardEntityToJSON,
    DictionaryEntity,
    DictionaryEntityFromJSON,
    DictionaryEntityToJSON,
    DictionaryListItem,
    DictionaryListItemFromJSON,
    DictionaryListItemToJSON,
    EntrypointEntity,
    EntrypointEntityFromJSON,
    EntrypointEntityToJSON,
    GenericNotificationConfigEntity,
    GenericNotificationConfigEntityFromJSON,
    GenericNotificationConfigEntityToJSON,
    GroupEntity,
    GroupEntityFromJSON,
    GroupEntityToJSON,
    GroupMemberEntity,
    GroupMemberEntityFromJSON,
    GroupMemberEntityToJSON,
    GroupMembership,
    GroupMembershipFromJSON,
    GroupMembershipToJSON,
    Hook,
    HookFromJSON,
    HookToJSON,
    IdentityProviderEntity,
    IdentityProviderEntityFromJSON,
    IdentityProviderEntityToJSON,
    IdentityProviderListItem,
    IdentityProviderListItemFromJSON,
    IdentityProviderListItemToJSON,
    InvitationEntity,
    InvitationEntityFromJSON,
    InvitationEntityToJSON,
    LifecycleAction,
    LifecycleActionFromJSON,
    LifecycleActionToJSON,
    MembershipListItem,
    MembershipListItemFromJSON,
    MembershipListItemToJSON,
    MetadataEntity,
    MetadataEntityFromJSON,
    MetadataEntityToJSON,
    NewApiHeaderEntity,
    NewApiHeaderEntityFromJSON,
    NewApiHeaderEntityToJSON,
    NewCategoryEntity,
    NewCategoryEntityFromJSON,
    NewCategoryEntityToJSON,
    NewClientRegistrationProviderEntity,
    NewClientRegistrationProviderEntityFromJSON,
    NewClientRegistrationProviderEntityToJSON,
    NewDashboardEntity,
    NewDashboardEntityFromJSON,
    NewDashboardEntityToJSON,
    NewDictionaryEntity,
    NewDictionaryEntityFromJSON,
    NewDictionaryEntityToJSON,
    NewEntryPointEntity,
    NewEntryPointEntityFromJSON,
    NewEntryPointEntityToJSON,
    NewGroupEntity,
    NewGroupEntityFromJSON,
    NewGroupEntityToJSON,
    NewIdentityProviderEntity,
    NewIdentityProviderEntityFromJSON,
    NewIdentityProviderEntityToJSON,
    NewInvitationEntity,
    NewInvitationEntityFromJSON,
    NewInvitationEntityToJSON,
    NewMetadataEntity,
    NewMetadataEntityFromJSON,
    NewMetadataEntityToJSON,
    NewQualityRuleEntity,
    NewQualityRuleEntityFromJSON,
    NewQualityRuleEntityToJSON,
    NewRoleEntity,
    NewRoleEntityFromJSON,
    NewRoleEntityToJSON,
    NewTagEntity,
    NewTagEntityFromJSON,
    NewTagEntityToJSON,
    NewTenantEntity,
    NewTenantEntityFromJSON,
    NewTenantEntityToJSON,
    NewThemeEntity,
    NewThemeEntityFromJSON,
    NewThemeEntityToJSON,
    NewTopApiEntity,
    NewTopApiEntityFromJSON,
    NewTopApiEntityToJSON,
    NotificationTemplateEntity,
    NotificationTemplateEntityFromJSON,
    NotificationTemplateEntityToJSON,
    NotifierEntity,
    NotifierEntityFromJSON,
    NotifierEntityToJSON,
    OrganizationFlowConfiguration,
    OrganizationFlowConfigurationFromJSON,
    OrganizationFlowConfigurationToJSON,
    PlansConfigurationEntity,
    PlansConfigurationEntityFromJSON,
    PlansConfigurationEntityToJSON,
    PortalNotificationConfigEntity,
    PortalNotificationConfigEntityFromJSON,
    PortalNotificationConfigEntityToJSON,
    QualityRuleEntity,
    QualityRuleEntityFromJSON,
    QualityRuleEntityToJSON,
    RoleEntity,
    RoleEntityFromJSON,
    RoleEntityToJSON,
    RoleMembership,
    RoleMembershipFromJSON,
    RoleMembershipToJSON,
    RoleScope,
    RoleScopeFromJSON,
    RoleScopeToJSON,
    TagEntity,
    TagEntityFromJSON,
    TagEntityToJSON,
    TenantEntity,
    TenantEntityFromJSON,
    TenantEntityToJSON,
    ThemeEntity,
    ThemeEntityFromJSON,
    ThemeEntityToJSON,
    TopApiEntity,
    TopApiEntityFromJSON,
    TopApiEntityToJSON,
    UpdateApiHeaderEntity,
    UpdateApiHeaderEntityFromJSON,
    UpdateApiHeaderEntityToJSON,
    UpdateCategoryEntity,
    UpdateCategoryEntityFromJSON,
    UpdateCategoryEntityToJSON,
    UpdateClientRegistrationProviderEntity,
    UpdateClientRegistrationProviderEntityFromJSON,
    UpdateClientRegistrationProviderEntityToJSON,
    UpdateDashboardEntity,
    UpdateDashboardEntityFromJSON,
    UpdateDashboardEntityToJSON,
    UpdateDictionaryEntity,
    UpdateDictionaryEntityFromJSON,
    UpdateDictionaryEntityToJSON,
    UpdateEntryPointEntity,
    UpdateEntryPointEntityFromJSON,
    UpdateEntryPointEntityToJSON,
    UpdateGroupEntity,
    UpdateGroupEntityFromJSON,
    UpdateGroupEntityToJSON,
    UpdateIdentityProviderEntity,
    UpdateIdentityProviderEntityFromJSON,
    UpdateIdentityProviderEntityToJSON,
    UpdateInvitationEntity,
    UpdateInvitationEntityFromJSON,
    UpdateInvitationEntityToJSON,
    UpdateMetadataEntity,
    UpdateMetadataEntityFromJSON,
    UpdateMetadataEntityToJSON,
    UpdateQualityRuleEntity,
    UpdateQualityRuleEntityFromJSON,
    UpdateQualityRuleEntityToJSON,
    UpdateRoleEntity,
    UpdateRoleEntityFromJSON,
    UpdateRoleEntityToJSON,
    UpdateTagEntity,
    UpdateTagEntityFromJSON,
    UpdateTagEntityToJSON,
    UpdateTenantEntity,
    UpdateTenantEntityFromJSON,
    UpdateTenantEntityToJSON,
    UpdateThemeEntity,
    UpdateThemeEntityFromJSON,
    UpdateThemeEntityToJSON,
    UpdateTopApiEntity,
    UpdateTopApiEntityFromJSON,
    UpdateTopApiEntityToJSON,
} from '../models';

export interface AddGroupMemberRequest {
    group: string;
    type?: string;
    envId: string;
    orgId: string;
}

export interface AddOrUpdateGroupMemberRequest {
    group: string;
    envId: string;
    orgId: string;
    groupMembership: Array<GroupMembership>;
}

export interface AddRoleToUserRequest {
    scope: RoleScope;
    role: string;
    orgId: string;
    roleMembership: RoleMembership;
}

export interface AddRoleToUser1Request {
    scope: RoleScope;
    role: string;
    envId: string;
    orgId: string;
    roleMembership: RoleMembership;
}

export interface CreateApiHeaderRequest {
    envId: string;
    orgId: string;
    newApiHeaderEntity: NewApiHeaderEntity;
}

export interface CreateCategoryRequest {
    envId: string;
    orgId: string;
    newCategoryEntity: NewCategoryEntity;
}

export interface CreateClientRegistrationProviderRequest {
    envId: string;
    orgId: string;
    newClientRegistrationProviderEntity: NewClientRegistrationProviderEntity;
}

export interface CreateCustomUserFieldRequest {
    orgId: string;
    customUserFieldEntity?: CustomUserFieldEntity;
}

export interface CreateDashboardRequest {
    envId: string;
    orgId: string;
    newDashboardEntity: NewDashboardEntity;
}

export interface CreateDictionaryRequest {
    envId: string;
    orgId: string;
    newDictionaryEntity: NewDictionaryEntity;
}

export interface CreateEntrypointRequest {
    orgId: string;
    newEntryPointEntity: NewEntryPointEntity;
}

export interface CreateEntrypoint1Request {
    envId: string;
    orgId: string;
    newEntryPointEntity: NewEntryPointEntity;
}

export interface CreateGroupRequest {
    envId: string;
    orgId: string;
    newGroupEntity: NewGroupEntity;
}

export interface CreateGroupInvitationRequest {
    group: string;
    envId: string;
    orgId: string;
    newInvitationEntity: NewInvitationEntity;
}

export interface CreateIdentityProviderRequest {
    orgId: string;
    newIdentityProviderEntity: NewIdentityProviderEntity;
}

export interface CreateIdentityProvider1Request {
    envId: string;
    orgId: string;
    newIdentityProviderEntity: NewIdentityProviderEntity;
}

export interface CreateMetadataRequest {
    envId: string;
    orgId: string;
    newMetadataEntity: NewMetadataEntity;
}

export interface CreateNotificationTemplateRequest {
    orgId: string;
    notificationTemplateEntity?: NotificationTemplateEntity;
}

export interface CreatePortalNotificationSettingRequest {
    envId: string;
    orgId: string;
    genericNotificationConfigEntity?: GenericNotificationConfigEntity;
}

export interface CreateQualityRuleRequest {
    envId: string;
    orgId: string;
    newQualityRuleEntity: NewQualityRuleEntity;
}

export interface CreateRoleRequest {
    scope: RoleScope;
    orgId: string;
    newRoleEntity: NewRoleEntity;
}

export interface CreateRole1Request {
    scope: RoleScope;
    envId: string;
    orgId: string;
    newRoleEntity: NewRoleEntity;
}

export interface CreateTagRequest {
    orgId: string;
    newTagEntity: NewTagEntity;
}

export interface CreateTag1Request {
    envId: string;
    orgId: string;
    newTagEntity: NewTagEntity;
}

export interface CreateTenantsRequest {
    orgId: string;
    newTenantEntity: Array<NewTenantEntity>;
}

export interface CreateTenants1Request {
    envId: string;
    orgId: string;
    newTenantEntity: Array<NewTenantEntity>;
}

export interface CreateThemeRequest {
    envId: string;
    orgId: string;
    newThemeEntity: NewThemeEntity;
}

export interface CreateTopApiRequest {
    envId: string;
    orgId: string;
    newTopApiEntity: NewTopApiEntity;
}

export interface DeleteApiHeaderRequest {
    id: string;
    envId: string;
    orgId: string;
}

export interface DeleteCategoryRequest {
    categoryId: string;
    envId: string;
    orgId: string;
}

export interface DeleteClientRegistrationProviderRequest {
    clientRegistrationProvider: string;
    envId: string;
    orgId: string;
}

export interface DeleteCustomUserFieldRequest {
    key: string;
    orgId: string;
}

export interface DeleteDashboardRequest {
    dashboardId: string;
    envId: string;
    orgId: string;
}

export interface DeleteDictionaryRequest {
    dictionary: string;
    envId: string;
    orgId: string;
}

export interface DeleteEntrypointRequest {
    entrypoint: string;
    orgId: string;
}

export interface DeleteEntrypoint1Request {
    entrypoint: string;
    envId: string;
    orgId: string;
}

export interface DeleteGroupRequest {
    group: string;
    envId: string;
    orgId: string;
}

export interface DeleteGroupInvitationRequest {
    invitation: string;
    group: string;
    envId: string;
    orgId: string;
}

export interface DeleteGroupMemberRequest {
    member: string;
    group: string;
    envId: string;
    orgId: string;
}

export interface DeleteIdentityProviderRequest {
    identityProvider: string;
    orgId: string;
}

export interface DeleteIdentityProvider1Request {
    identityProvider: string;
    envId: string;
    orgId: string;
}

export interface DeleteMetadataRequest {
    metadata: string;
    envId: string;
    orgId: string;
}

export interface DeleteNotificationSettingsRequest {
    notificationId: string;
    envId: string;
    orgId: string;
}

export interface DeleteQualityRuleRequest {
    id: string;
    envId: string;
    orgId: string;
}

export interface DeleteRoleRequest {
    scope: RoleScope;
    role: string;
    orgId: string;
}

export interface DeleteRole1Request {
    scope: RoleScope;
    role: string;
    envId: string;
    orgId: string;
}

export interface DeleteRoleForUserRequest {
    scope: RoleScope;
    role: string;
    userId: string;
    orgId: string;
}

export interface DeleteRoleForUser1Request {
    scope: RoleScope;
    role: string;
    userId: string;
    envId: string;
    orgId: string;
}

export interface DeleteTagRequest {
    tag: string;
    orgId: string;
}

export interface DeleteTag1Request {
    tag: string;
    envId: string;
    orgId: string;
}

export interface DeleteTenantRequest {
    tenant: string;
    orgId: string;
}

export interface DeleteTenant1Request {
    tenant: string;
    envId: string;
    orgId: string;
}

export interface DeleteThemeRequest {
    themeId: string;
    envId: string;
    orgId: string;
}

export interface DeleteTopApiRequest {
    topAPI: string;
    envId: string;
    orgId: string;
}

export interface DeployDictionaryRequest {
    dictionary: string;
    envId: string;
    orgId: string;
}

export interface DoLifecycleActionRequest {
    action: LifecycleAction;
    dictionary: string;
    envId: string;
    orgId: string;
}

export interface GetApiHeadersRequest {
    envId: string;
    orgId: string;
}

export interface GetCategoriesRequest {
    envId: string;
    orgId: string;
}

export interface GetCategoryRequest {
    categoryId: string;
    envId: string;
    orgId: string;
}

export interface GetCategoryBackgroundRequest {
    categoryId: string;
    envId: string;
    orgId: string;
}

export interface GetCategoryPictureRequest {
    categoryId: string;
    envId: string;
    orgId: string;
}

export interface GetClientRegistrationProviderRequest {
    clientRegistrationProvider: string;
    envId: string;
    orgId: string;
}

export interface GetClientRegistrationProvidersRequest {
    envId: string;
    orgId: string;
}

export interface GetConfigurationHooksRequest {
    envId: string;
    orgId: string;
}

export interface GetConfigurationSchemaFormRequest {
    orgId: string;
}

export interface GetCustomUserFieldsRequest {
    orgId: string;
}

export interface GetDashboardRequest {
    dashboardId: string;
    envId: string;
    orgId: string;
}

export interface GetDashboardsRequest {
    referenceType?: GetDashboardsReferenceTypeEnum;
    envId: string;
    orgId: string;
}

export interface GetDictionariesRequest {
    envId: string;
    orgId: string;
}

export interface GetDictionaryRequest {
    dictionary: string;
    envId: string;
    orgId: string;
}

export interface GetEnabledApplicationTypesRequest {
    envId: string;
    orgId: string;
}

export interface GetEntrypointRequest {
    entrypoint: string;
    orgId: string;
}

export interface GetEntrypoint1Request {
    entrypoint: string;
    envId: string;
    orgId: string;
}

export interface GetEntrypointsRequest {
    orgId: string;
}

export interface GetEntrypoints1Request {
    envId: string;
    orgId: string;
}

export interface GetFaviconRequest {
    themeId: string;
    envId: string;
    orgId: string;
}

export interface GetGrammarRequest {
    envId: string;
    orgId: string;
}

export interface GetGroupRequest {
    group: string;
    envId: string;
    orgId: string;
}

export interface GetGroupInvitationsRequest {
    group: string;
    envId: string;
    orgId: string;
}

export interface GetGroupMembersRequest {
    group: string;
    envId: string;
    orgId: string;
}

export interface GetGroupMembers1Request {
    size?: number;
    page?: number;
    group: string;
    envId: string;
    orgId: string;
}

export interface GetGroupMembershipsRequest {
    group: string;
    type?: string;
    envId: string;
    orgId: string;
}

export interface GetGroupsRequest {
    envId: string;
    orgId: string;
}

export interface GetIdentityProviderRequest {
    identityProvider: string;
    orgId: string;
}

export interface GetIdentityProvider1Request {
    identityProvider: string;
    envId: string;
    orgId: string;
}

export interface GetIdentityProvidersRequest {
    orgId: string;
}

export interface GetIdentityProviders1Request {
    envId: string;
    orgId: string;
}

export interface GetLogoLightRequest {
    themeId: string;
    envId: string;
    orgId: string;
}

export interface GetMetadatasRequest {
    envId: string;
    orgId: string;
}

export interface GetNotificationTemplateRequest {
    notificationTemplateId: string;
    orgId: string;
}

export interface GetNotificationTemplatesRequest {
    scope?: string;
    hook?: string;
    orgId: string;
}

export interface GetPlansConfigurationRequest {
    envId: string;
    orgId: string;
}

export interface GetPlatformFlowSchemaFormRequest {
    orgId: string;
}

export interface GetPortalNotificationSettingsRequest {
    envId: string;
    orgId: string;
}

export interface GetPortalNotifiersRequest {
    envId: string;
    orgId: string;
}

export interface GetQualityRuleRequest {
    id: string;
    envId: string;
    orgId: string;
}

export interface GetQualityRulesRequest {
    envId: string;
    orgId: string;
}

export interface GetRoleRequest {
    scope: RoleScope;
    role: string;
    orgId: string;
}

export interface GetRole1Request {
    scope: RoleScope;
    role: string;
    envId: string;
    orgId: string;
}

export interface GetRoleScopesRequest {
    orgId: string;
}

export interface GetRoleScopes1Request {
    envId: string;
    orgId: string;
}

export interface GetRolesRequest {
    scope: RoleScope;
    orgId: string;
}

export interface GetRoles1Request {
    scope: RoleScope;
    envId: string;
    orgId: string;
}

export interface GetTagRequest {
    tag: string;
    orgId: string;
}

export interface GetTag1Request {
    tag: string;
    envId: string;
    orgId: string;
}

export interface GetTagsRequest {
    orgId: string;
}

export interface GetTags1Request {
    envId: string;
    orgId: string;
}

export interface GetTenantsRequest {
    orgId: string;
}

export interface GetTenants1Request {
    envId: string;
    orgId: string;
}

export interface GetThemeRequest {
    themeId: string;
    envId: string;
    orgId: string;
}

export interface GetThemeBackgroundRequest {
    themeId: string;
    envId: string;
    orgId: string;
}

export interface GetThemeLogoRequest {
    themeId: string;
    envId: string;
    orgId: string;
}

export interface GetTopApisRequest {
    envId: string;
    orgId: string;
}

export interface GetUsersPerRoleRequest {
    scope: RoleScope;
    role: string;
    orgId: string;
}

export interface GetUsersPerRole1Request {
    scope: RoleScope;
    role: string;
    envId: string;
    orgId: string;
}

export interface HasPoliciesRequest {
    orgId: string;
}

export interface ResetThemeRequest {
    themeId: string;
    envId: string;
    orgId: string;
}

export interface UndeployDictionaryRequest {
    dictionary: string;
    envId: string;
    orgId: string;
}

export interface UpdateApiHeaderRequest {
    id: string;
    envId: string;
    orgId: string;
    updateApiHeaderEntity: UpdateApiHeaderEntity;
}

export interface UpdateCategoriesRequest {
    envId: string;
    orgId: string;
    updateCategoryEntity: Array<UpdateCategoryEntity>;
}

export interface UpdateCategoryRequest {
    categoryId: string;
    envId: string;
    orgId: string;
    updateCategoryEntity: UpdateCategoryEntity;
}

export interface UpdateClientRegistrationProviderRequest {
    clientRegistrationProvider: string;
    envId: string;
    orgId: string;
    updateClientRegistrationProviderEntity: UpdateClientRegistrationProviderEntity;
}

export interface UpdateCustomUserFieldRequest {
    key: string;
    orgId: string;
    customUserFieldEntity?: CustomUserFieldEntity;
}

export interface UpdateDashboardRequest {
    dashboardId: string;
    envId: string;
    orgId: string;
    updateDashboardEntity: UpdateDashboardEntity;
}

export interface UpdateDictionaryRequest {
    dictionary: string;
    envId: string;
    orgId: string;
    updateDictionaryEntity: UpdateDictionaryEntity;
}

export interface UpdateEntrypointRequest {
    orgId: string;
    updateEntryPointEntity: UpdateEntryPointEntity;
}

export interface UpdateEntrypoint1Request {
    envId: string;
    orgId: string;
    updateEntryPointEntity: UpdateEntryPointEntity;
}

export interface UpdateGenericNotificationSettingsRequest {
    notificationId: string;
    envId: string;
    orgId: string;
    genericNotificationConfigEntity?: GenericNotificationConfigEntity;
}

export interface UpdateGroupRequest {
    group: string;
    envId: string;
    orgId: string;
    updateGroupEntity: UpdateGroupEntity;
}

export interface UpdateGroupInvitationRequest {
    invitation: string;
    group: string;
    envId: string;
    orgId: string;
    updateInvitationEntity: UpdateInvitationEntity;
}

export interface UpdateIdentityProviderRequest {
    identityProvider: string;
    orgId: string;
    updateIdentityProviderEntity: UpdateIdentityProviderEntity;
}

export interface UpdateIdentityProvider1Request {
    identityProvider: string;
    envId: string;
    orgId: string;
    updateIdentityProviderEntity: UpdateIdentityProviderEntity;
}

export interface UpdateMetadataRequest {
    envId: string;
    orgId: string;
    updateMetadataEntity: UpdateMetadataEntity;
}

export interface UpdateNotificationTemplateRequest {
    notificationTemplateId: string;
    orgId: string;
    notificationTemplateEntity?: NotificationTemplateEntity;
}

export interface UpdatePortalNotificationSettingsRequest {
    envId: string;
    orgId: string;
    portalNotificationConfigEntity?: PortalNotificationConfigEntity;
}

export interface UpdateQualityRuleRequest {
    id: string;
    envId: string;
    orgId: string;
    updateQualityRuleEntity: UpdateQualityRuleEntity;
}

export interface UpdateRoleRequest {
    scope: RoleScope;
    role: string;
    orgId: string;
    updateRoleEntity: UpdateRoleEntity;
}

export interface UpdateRole1Request {
    scope: RoleScope;
    role: string;
    envId: string;
    orgId: string;
    updateRoleEntity: UpdateRoleEntity;
}

export interface UpdateTagRequest {
    tag: string;
    orgId: string;
    updateTagEntity: UpdateTagEntity;
}

export interface UpdateTag1Request {
    tag: string;
    envId: string;
    orgId: string;
    updateTagEntity: UpdateTagEntity;
}

export interface UpdateTenantsRequest {
    orgId: string;
    updateTenantEntity: Array<UpdateTenantEntity>;
}

export interface UpdateTenants1Request {
    envId: string;
    orgId: string;
    updateTenantEntity: Array<UpdateTenantEntity>;
}

export interface UpdateThemeRequest {
    themeId: string;
    envId: string;
    orgId: string;
    updateThemeEntity: UpdateThemeEntity;
}

export interface UpdateTopApiRequest {
    envId: string;
    orgId: string;
    updateTopApiEntity: Array<UpdateTopApiEntity>;
}

/**
 * 
 */
export class ConfigurationApi extends runtime.BaseAPI {

    /**
     * Associate a group to existing APIs or Applications
     */
    async addGroupMemberRaw(requestParameters: AddGroupMemberRequest): Promise<runtime.ApiResponse<GroupEntity>> {
        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling addGroupMember.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling addGroupMember.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling addGroupMember.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups/{group}/memberships`.replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupEntityFromJSON(jsonValue));
    }

    /**
     * Associate a group to existing APIs or Applications
     */
    async addGroupMember(requestParameters: AddGroupMemberRequest): Promise<GroupEntity> {
        const response = await this.addGroupMemberRaw(requestParameters);
        return await response.value();
    }

    /**
     * Add or update a group member
     */
    async addOrUpdateGroupMemberRaw(requestParameters: AddOrUpdateGroupMemberRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling addOrUpdateGroupMember.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling addOrUpdateGroupMember.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling addOrUpdateGroupMember.');
        }

        if (requestParameters.groupMembership === null || requestParameters.groupMembership === undefined) {
            throw new runtime.RequiredError('groupMembership','Required parameter requestParameters.groupMembership was null or undefined when calling addOrUpdateGroupMember.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups/{group}/members`.replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.groupMembership.map(GroupMembershipToJSON),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add or update a group member
     */
    async addOrUpdateGroupMember(requestParameters: AddOrUpdateGroupMemberRequest): Promise<void> {
        await this.addOrUpdateGroupMemberRaw(requestParameters);
    }

    /**
     * User must have the MANAGEMENT_ROLE[CREATE] and MANAGEMENT_ROLE[UPDATE] permission to use this service
     * Add or update a role for a user
     */
    async addRoleToUserRaw(requestParameters: AddRoleToUserRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling addRoleToUser.');
        }

        if (requestParameters.role === null || requestParameters.role === undefined) {
            throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling addRoleToUser.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling addRoleToUser.');
        }

        if (requestParameters.roleMembership === null || requestParameters.roleMembership === undefined) {
            throw new runtime.RequiredError('roleMembership','Required parameter requestParameters.roleMembership was null or undefined when calling addRoleToUser.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/rolescopes/{scope}/roles/{role}/users`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"role"}}`, encodeURIComponent(String(requestParameters.role))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RoleMembershipToJSON(requestParameters.roleMembership),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGEMENT_ROLE[CREATE] and MANAGEMENT_ROLE[UPDATE] permission to use this service
     * Add or update a role for a user
     */
    async addRoleToUser(requestParameters: AddRoleToUserRequest): Promise<void> {
        await this.addRoleToUserRaw(requestParameters);
    }

    /**
     * User must have the MANAGEMENT_ROLE[CREATE] and MANAGEMENT_ROLE[UPDATE] permission to use this service
     * Add or update a role for a user
     */
    async addRoleToUser1Raw(requestParameters: AddRoleToUser1Request): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling addRoleToUser1.');
        }

        if (requestParameters.role === null || requestParameters.role === undefined) {
            throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling addRoleToUser1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling addRoleToUser1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling addRoleToUser1.');
        }

        if (requestParameters.roleMembership === null || requestParameters.roleMembership === undefined) {
            throw new runtime.RequiredError('roleMembership','Required parameter requestParameters.roleMembership was null or undefined when calling addRoleToUser1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/rolescopes/{scope}/roles/{role}/users`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"role"}}`, encodeURIComponent(String(requestParameters.role))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RoleMembershipToJSON(requestParameters.roleMembership),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGEMENT_ROLE[CREATE] and MANAGEMENT_ROLE[UPDATE] permission to use this service
     * Add or update a role for a user
     */
    async addRoleToUser1(requestParameters: AddRoleToUser1Request): Promise<void> {
        await this.addRoleToUser1Raw(requestParameters);
    }

    /**
     * User must have the PORTAL_API_HEADER[CREATE] permission to use this service
     * Create an API header
     */
    async createApiHeaderRaw(requestParameters: CreateApiHeaderRequest): Promise<runtime.ApiResponse<ApiHeaderEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createApiHeader.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createApiHeader.');
        }

        if (requestParameters.newApiHeaderEntity === null || requestParameters.newApiHeaderEntity === undefined) {
            throw new runtime.RequiredError('newApiHeaderEntity','Required parameter requestParameters.newApiHeaderEntity was null or undefined when calling createApiHeader.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/apiheaders`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewApiHeaderEntityToJSON(requestParameters.newApiHeaderEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiHeaderEntityFromJSON(jsonValue));
    }

    /**
     * User must have the PORTAL_API_HEADER[CREATE] permission to use this service
     * Create an API header
     */
    async createApiHeader(requestParameters: CreateApiHeaderRequest): Promise<ApiHeaderEntity> {
        const response = await this.createApiHeaderRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_CATEGORY[CREATE] permission to use this service
     * Create a category
     */
    async createCategoryRaw(requestParameters: CreateCategoryRequest): Promise<runtime.ApiResponse<CategoryEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createCategory.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createCategory.');
        }

        if (requestParameters.newCategoryEntity === null || requestParameters.newCategoryEntity === undefined) {
            throw new runtime.RequiredError('newCategoryEntity','Required parameter requestParameters.newCategoryEntity was null or undefined when calling createCategory.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/categories`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewCategoryEntityToJSON(requestParameters.newCategoryEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CategoryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the PORTAL_CATEGORY[CREATE] permission to use this service
     * Create a category
     */
    async createCategory(requestParameters: CreateCategoryRequest): Promise<CategoryEntity> {
        const response = await this.createCategoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_CLIENT_REGISTRATION_PROVIDER[CREATE] permission to use this service
     * Create a client registration provider
     */
    async createClientRegistrationProviderRaw(requestParameters: CreateClientRegistrationProviderRequest): Promise<runtime.ApiResponse<ClientRegistrationProviderEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createClientRegistrationProvider.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createClientRegistrationProvider.');
        }

        if (requestParameters.newClientRegistrationProviderEntity === null || requestParameters.newClientRegistrationProviderEntity === undefined) {
            throw new runtime.RequiredError('newClientRegistrationProviderEntity','Required parameter requestParameters.newClientRegistrationProviderEntity was null or undefined when calling createClientRegistrationProvider.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/applications/registration/providers`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewClientRegistrationProviderEntityToJSON(requestParameters.newClientRegistrationProviderEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ClientRegistrationProviderEntityFromJSON(jsonValue));
    }

    /**
     * User must have the PORTAL_CLIENT_REGISTRATION_PROVIDER[CREATE] permission to use this service
     * Create a client registration provider
     */
    async createClientRegistrationProvider(requestParameters: CreateClientRegistrationProviderRequest): Promise<ClientRegistrationProviderEntity> {
        const response = await this.createClientRegistrationProviderRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the CUSTOM_USER_FIELDS[CREATE] permission to use this service
     * Create a Custom User Field
     */
    async createCustomUserFieldRaw(requestParameters: CreateCustomUserFieldRequest): Promise<runtime.ApiResponse<CustomUserFieldEntity>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createCustomUserField.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/custom-user-fields`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomUserFieldEntityToJSON(requestParameters.customUserFieldEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomUserFieldEntityFromJSON(jsonValue));
    }

    /**
     * User must have the CUSTOM_USER_FIELDS[CREATE] permission to use this service
     * Create a Custom User Field
     */
    async createCustomUserField(requestParameters: CreateCustomUserFieldRequest): Promise<CustomUserFieldEntity> {
        const response = await this.createCustomUserFieldRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_DASHBOARD[CREATE] permission to use this service
     * Create a platform dashboard
     */
    async createDashboardRaw(requestParameters: CreateDashboardRequest): Promise<runtime.ApiResponse<DashboardEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createDashboard.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createDashboard.');
        }

        if (requestParameters.newDashboardEntity === null || requestParameters.newDashboardEntity === undefined) {
            throw new runtime.RequiredError('newDashboardEntity','Required parameter requestParameters.newDashboardEntity was null or undefined when calling createDashboard.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dashboards`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewDashboardEntityToJSON(requestParameters.newDashboardEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DashboardEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_DASHBOARD[CREATE] permission to use this service
     * Create a platform dashboard
     */
    async createDashboard(requestParameters: CreateDashboardRequest): Promise<DashboardEntity> {
        const response = await this.createDashboardRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the DICTIONARY[CREATE] permission to use this service
     * Create a dictionary
     */
    async createDictionaryRaw(requestParameters: CreateDictionaryRequest): Promise<runtime.ApiResponse<DictionaryEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createDictionary.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createDictionary.');
        }

        if (requestParameters.newDictionaryEntity === null || requestParameters.newDictionaryEntity === undefined) {
            throw new runtime.RequiredError('newDictionaryEntity','Required parameter requestParameters.newDictionaryEntity was null or undefined when calling createDictionary.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewDictionaryEntityToJSON(requestParameters.newDictionaryEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DictionaryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the DICTIONARY[CREATE] permission to use this service
     * Create a dictionary
     */
    async createDictionary(requestParameters: CreateDictionaryRequest): Promise<DictionaryEntity> {
        const response = await this.createDictionaryRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[CREATE] permission to use this service
     * Create a platform entrypoint
     */
    async createEntrypointRaw(requestParameters: CreateEntrypointRequest): Promise<runtime.ApiResponse<EntrypointEntity>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createEntrypoint.');
        }

        if (requestParameters.newEntryPointEntity === null || requestParameters.newEntryPointEntity === undefined) {
            throw new runtime.RequiredError('newEntryPointEntity','Required parameter requestParameters.newEntryPointEntity was null or undefined when calling createEntrypoint.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/entrypoints`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewEntryPointEntityToJSON(requestParameters.newEntryPointEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EntrypointEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[CREATE] permission to use this service
     * Create a platform entrypoint
     */
    async createEntrypoint(requestParameters: CreateEntrypointRequest): Promise<EntrypointEntity> {
        const response = await this.createEntrypointRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[CREATE] permission to use this service
     * Create a platform entrypoint
     */
    async createEntrypoint1Raw(requestParameters: CreateEntrypoint1Request): Promise<runtime.ApiResponse<EntrypointEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createEntrypoint1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createEntrypoint1.');
        }

        if (requestParameters.newEntryPointEntity === null || requestParameters.newEntryPointEntity === undefined) {
            throw new runtime.RequiredError('newEntryPointEntity','Required parameter requestParameters.newEntryPointEntity was null or undefined when calling createEntrypoint1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/entrypoints`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewEntryPointEntityToJSON(requestParameters.newEntryPointEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EntrypointEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[CREATE] permission to use this service
     * Create a platform entrypoint
     */
    async createEntrypoint1(requestParameters: CreateEntrypoint1Request): Promise<EntrypointEntity> {
        const response = await this.createEntrypoint1Raw(requestParameters);
        return await response.value();
    }

    /**
     * Create a new group.
     * Create group
     */
    async createGroupRaw(requestParameters: CreateGroupRequest): Promise<runtime.ApiResponse<GroupEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createGroup.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createGroup.');
        }

        if (requestParameters.newGroupEntity === null || requestParameters.newGroupEntity === undefined) {
            throw new runtime.RequiredError('newGroupEntity','Required parameter requestParameters.newGroupEntity was null or undefined when calling createGroup.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewGroupEntityToJSON(requestParameters.newGroupEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupEntityFromJSON(jsonValue));
    }

    /**
     * Create a new group.
     * Create group
     */
    async createGroup(requestParameters: CreateGroupRequest): Promise<GroupEntity> {
        const response = await this.createGroupRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the GROUP_INVITATION[CREATE] permission to use this service
     * Create an invitation to join a group
     */
    async createGroupInvitationRaw(requestParameters: CreateGroupInvitationRequest): Promise<runtime.ApiResponse<InvitationEntity>> {
        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling createGroupInvitation.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createGroupInvitation.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createGroupInvitation.');
        }

        if (requestParameters.newInvitationEntity === null || requestParameters.newInvitationEntity === undefined) {
            throw new runtime.RequiredError('newInvitationEntity','Required parameter requestParameters.newInvitationEntity was null or undefined when calling createGroupInvitation.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups/{group}/invitations`.replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewInvitationEntityToJSON(requestParameters.newInvitationEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InvitationEntityFromJSON(jsonValue));
    }

    /**
     * User must have the GROUP_INVITATION[CREATE] permission to use this service
     * Create an invitation to join a group
     */
    async createGroupInvitation(requestParameters: CreateGroupInvitationRequest): Promise<InvitationEntity> {
        const response = await this.createGroupInvitationRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[CREATE] permission to use this service
     * Create an identity provider
     */
    async createIdentityProviderRaw(requestParameters: CreateIdentityProviderRequest): Promise<runtime.ApiResponse<IdentityProviderEntity>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createIdentityProvider.');
        }

        if (requestParameters.newIdentityProviderEntity === null || requestParameters.newIdentityProviderEntity === undefined) {
            throw new runtime.RequiredError('newIdentityProviderEntity','Required parameter requestParameters.newIdentityProviderEntity was null or undefined when calling createIdentityProvider.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/identities`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewIdentityProviderEntityToJSON(requestParameters.newIdentityProviderEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdentityProviderEntityFromJSON(jsonValue));
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[CREATE] permission to use this service
     * Create an identity provider
     */
    async createIdentityProvider(requestParameters: CreateIdentityProviderRequest): Promise<IdentityProviderEntity> {
        const response = await this.createIdentityProviderRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[CREATE] permission to use this service
     * Create an identity provider
     */
    async createIdentityProvider1Raw(requestParameters: CreateIdentityProvider1Request): Promise<runtime.ApiResponse<IdentityProviderEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createIdentityProvider1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createIdentityProvider1.');
        }

        if (requestParameters.newIdentityProviderEntity === null || requestParameters.newIdentityProviderEntity === undefined) {
            throw new runtime.RequiredError('newIdentityProviderEntity','Required parameter requestParameters.newIdentityProviderEntity was null or undefined when calling createIdentityProvider1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/identities`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewIdentityProviderEntityToJSON(requestParameters.newIdentityProviderEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdentityProviderEntityFromJSON(jsonValue));
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[CREATE] permission to use this service
     * Create an identity provider
     */
    async createIdentityProvider1(requestParameters: CreateIdentityProvider1Request): Promise<IdentityProviderEntity> {
        const response = await this.createIdentityProvider1Raw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_METADATA[CREATE] permission to use this service
     * Create a platform metadata
     */
    async createMetadataRaw(requestParameters: CreateMetadataRequest): Promise<runtime.ApiResponse<MetadataEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createMetadata.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createMetadata.');
        }

        if (requestParameters.newMetadataEntity === null || requestParameters.newMetadataEntity === undefined) {
            throw new runtime.RequiredError('newMetadataEntity','Required parameter requestParameters.newMetadataEntity was null or undefined when calling createMetadata.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/metadata`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewMetadataEntityToJSON(requestParameters.newMetadataEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MetadataEntityFromJSON(jsonValue));
    }

    /**
     * User must have the PORTAL_METADATA[CREATE] permission to use this service
     * Create a platform metadata
     */
    async createMetadata(requestParameters: CreateMetadataRequest): Promise<MetadataEntity> {
        const response = await this.createMetadataRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the NOTIFICATION_TEMPLATES[CREATE] permission to use this service
     * Create a notification template
     */
    async createNotificationTemplateRaw(requestParameters: CreateNotificationTemplateRequest): Promise<runtime.ApiResponse<NotificationTemplateEntity>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createNotificationTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/notification-templates`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NotificationTemplateEntityToJSON(requestParameters.notificationTemplateEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => NotificationTemplateEntityFromJSON(jsonValue));
    }

    /**
     * User must have the NOTIFICATION_TEMPLATES[CREATE] permission to use this service
     * Create a notification template
     */
    async createNotificationTemplate(requestParameters: CreateNotificationTemplateRequest): Promise<NotificationTemplateEntity> {
        const response = await this.createNotificationTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create notification settings
     */
    async createPortalNotificationSettingRaw(requestParameters: CreatePortalNotificationSettingRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createPortalNotificationSetting.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createPortalNotificationSetting.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/notificationsettings`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenericNotificationConfigEntityToJSON(requestParameters.genericNotificationConfigEntity),
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Create notification settings
     */
    async createPortalNotificationSetting(requestParameters: CreatePortalNotificationSettingRequest): Promise<any> {
        const response = await this.createPortalNotificationSettingRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_QUALITY_RULE[CREATE] permission to use this service
     * Create a quality rule
     */
    async createQualityRuleRaw(requestParameters: CreateQualityRuleRequest): Promise<runtime.ApiResponse<QualityRuleEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createQualityRule.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createQualityRule.');
        }

        if (requestParameters.newQualityRuleEntity === null || requestParameters.newQualityRuleEntity === undefined) {
            throw new runtime.RequiredError('newQualityRuleEntity','Required parameter requestParameters.newQualityRuleEntity was null or undefined when calling createQualityRule.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/quality-rules`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewQualityRuleEntityToJSON(requestParameters.newQualityRuleEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => QualityRuleEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_QUALITY_RULE[CREATE] permission to use this service
     * Create a quality rule
     */
    async createQualityRule(requestParameters: CreateQualityRuleRequest): Promise<QualityRuleEntity> {
        const response = await this.createQualityRuleRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ROLE[CREATE] permission to use this service
     * Create a role
     */
    async createRoleRaw(requestParameters: CreateRoleRequest): Promise<runtime.ApiResponse<RoleEntity>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling createRole.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createRole.');
        }

        if (requestParameters.newRoleEntity === null || requestParameters.newRoleEntity === undefined) {
            throw new runtime.RequiredError('newRoleEntity','Required parameter requestParameters.newRoleEntity was null or undefined when calling createRole.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/rolescopes/{scope}/roles`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewRoleEntityToJSON(requestParameters.newRoleEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ROLE[CREATE] permission to use this service
     * Create a role
     */
    async createRole(requestParameters: CreateRoleRequest): Promise<RoleEntity> {
        const response = await this.createRoleRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ROLE[CREATE] permission to use this service
     * Create a role
     */
    async createRole1Raw(requestParameters: CreateRole1Request): Promise<runtime.ApiResponse<RoleEntity>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling createRole1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createRole1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createRole1.');
        }

        if (requestParameters.newRoleEntity === null || requestParameters.newRoleEntity === undefined) {
            throw new runtime.RequiredError('newRoleEntity','Required parameter requestParameters.newRoleEntity was null or undefined when calling createRole1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/rolescopes/{scope}/roles`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewRoleEntityToJSON(requestParameters.newRoleEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ROLE[CREATE] permission to use this service
     * Create a role
     */
    async createRole1(requestParameters: CreateRole1Request): Promise<RoleEntity> {
        const response = await this.createRole1Raw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_TAG[CREATE] permission to use this service
     * Create a sharding tag
     */
    async createTagRaw(requestParameters: CreateTagRequest): Promise<runtime.ApiResponse<TagEntity>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createTag.');
        }

        if (requestParameters.newTagEntity === null || requestParameters.newTagEntity === undefined) {
            throw new runtime.RequiredError('newTagEntity','Required parameter requestParameters.newTagEntity was null or undefined when calling createTag.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/tags`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewTagEntityToJSON(requestParameters.newTagEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TagEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_TAG[CREATE] permission to use this service
     * Create a sharding tag
     */
    async createTag(requestParameters: CreateTagRequest): Promise<TagEntity> {
        const response = await this.createTagRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_TAG[CREATE] permission to use this service
     * Create a sharding tag
     */
    async createTag1Raw(requestParameters: CreateTag1Request): Promise<runtime.ApiResponse<TagEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createTag1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createTag1.');
        }

        if (requestParameters.newTagEntity === null || requestParameters.newTagEntity === undefined) {
            throw new runtime.RequiredError('newTagEntity','Required parameter requestParameters.newTagEntity was null or undefined when calling createTag1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/tags`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewTagEntityToJSON(requestParameters.newTagEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TagEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_TAG[CREATE] permission to use this service
     * Create a sharding tag
     */
    async createTag1(requestParameters: CreateTag1Request): Promise<TagEntity> {
        const response = await this.createTag1Raw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_TENANT[CREATE] permission to use this service
     * Create a tenant
     */
    async createTenantsRaw(requestParameters: CreateTenantsRequest): Promise<runtime.ApiResponse<Array<TenantEntity>>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createTenants.');
        }

        if (requestParameters.newTenantEntity === null || requestParameters.newTenantEntity === undefined) {
            throw new runtime.RequiredError('newTenantEntity','Required parameter requestParameters.newTenantEntity was null or undefined when calling createTenants.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/tenants`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.newTenantEntity.map(NewTenantEntityToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TenantEntityFromJSON));
    }

    /**
     * User must have the MANAGEMENT_TENANT[CREATE] permission to use this service
     * Create a tenant
     */
    async createTenants(requestParameters: CreateTenantsRequest): Promise<Array<TenantEntity>> {
        const response = await this.createTenantsRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_TENANT[CREATE] permission to use this service
     * Create a tenant
     */
    async createTenants1Raw(requestParameters: CreateTenants1Request): Promise<runtime.ApiResponse<Array<TenantEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createTenants1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createTenants1.');
        }

        if (requestParameters.newTenantEntity === null || requestParameters.newTenantEntity === undefined) {
            throw new runtime.RequiredError('newTenantEntity','Required parameter requestParameters.newTenantEntity was null or undefined when calling createTenants1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/tenants`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.newTenantEntity.map(NewTenantEntityToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TenantEntityFromJSON));
    }

    /**
     * User must have the MANAGEMENT_TENANT[CREATE] permission to use this service
     * Create a tenant
     */
    async createTenants1(requestParameters: CreateTenants1Request): Promise<Array<TenantEntity>> {
        const response = await this.createTenants1Raw(requestParameters);
        return await response.value();
    }

    /**
     */
    async createThemeRaw(requestParameters: CreateThemeRequest): Promise<runtime.ApiResponse<ThemeEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createTheme.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createTheme.');
        }

        if (requestParameters.newThemeEntity === null || requestParameters.newThemeEntity === undefined) {
            throw new runtime.RequiredError('newThemeEntity','Required parameter requestParameters.newThemeEntity was null or undefined when calling createTheme.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/themes`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewThemeEntityToJSON(requestParameters.newThemeEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ThemeEntityFromJSON(jsonValue));
    }

    /**
     */
    async createTheme(requestParameters: CreateThemeRequest): Promise<ThemeEntity> {
        const response = await this.createThemeRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_TOP_APIS[CREATE] permission to use this service
     * Create a top API
     */
    async createTopApiRaw(requestParameters: CreateTopApiRequest): Promise<runtime.ApiResponse<Array<TopApiEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createTopApi.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createTopApi.');
        }

        if (requestParameters.newTopApiEntity === null || requestParameters.newTopApiEntity === undefined) {
            throw new runtime.RequiredError('newTopApiEntity','Required parameter requestParameters.newTopApiEntity was null or undefined when calling createTopApi.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/top-apis`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewTopApiEntityToJSON(requestParameters.newTopApiEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TopApiEntityFromJSON));
    }

    /**
     * User must have the PORTAL_TOP_APIS[CREATE] permission to use this service
     * Create a top API
     */
    async createTopApi(requestParameters: CreateTopApiRequest): Promise<Array<TopApiEntity>> {
        const response = await this.createTopApiRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_API_HEADER[DELETE] permission to use this service
     * Delete an API header
     */
    async deleteApiHeaderRaw(requestParameters: DeleteApiHeaderRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteApiHeader.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteApiHeader.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteApiHeader.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/apiheaders/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the PORTAL_API_HEADER[DELETE] permission to use this service
     * Delete an API header
     */
    async deleteApiHeader(requestParameters: DeleteApiHeaderRequest): Promise<void> {
        await this.deleteApiHeaderRaw(requestParameters);
    }

    /**
     * User must have the PORTAL_CATEGORY[DELETE] permission to use this service
     * Delete the category
     */
    async deleteCategoryRaw(requestParameters: DeleteCategoryRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.categoryId === null || requestParameters.categoryId === undefined) {
            throw new runtime.RequiredError('categoryId','Required parameter requestParameters.categoryId was null or undefined when calling deleteCategory.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteCategory.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteCategory.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/categories/{categoryId}`.replace(`{${"categoryId"}}`, encodeURIComponent(String(requestParameters.categoryId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the PORTAL_CATEGORY[DELETE] permission to use this service
     * Delete the category
     */
    async deleteCategory(requestParameters: DeleteCategoryRequest): Promise<void> {
        await this.deleteCategoryRaw(requestParameters);
    }

    /**
     * User must have the PORTAL_CLIENT_REGISTRATION_PROVIDER[DELETE] permission to use this service
     * Delete a client registration provider
     */
    async deleteClientRegistrationProviderRaw(requestParameters: DeleteClientRegistrationProviderRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.clientRegistrationProvider === null || requestParameters.clientRegistrationProvider === undefined) {
            throw new runtime.RequiredError('clientRegistrationProvider','Required parameter requestParameters.clientRegistrationProvider was null or undefined when calling deleteClientRegistrationProvider.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteClientRegistrationProvider.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteClientRegistrationProvider.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/applications/registration/providers/{clientRegistrationProvider}`.replace(`{${"clientRegistrationProvider"}}`, encodeURIComponent(String(requestParameters.clientRegistrationProvider))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the PORTAL_CLIENT_REGISTRATION_PROVIDER[DELETE] permission to use this service
     * Delete a client registration provider
     */
    async deleteClientRegistrationProvider(requestParameters: DeleteClientRegistrationProviderRequest): Promise<void> {
        await this.deleteClientRegistrationProviderRaw(requestParameters);
    }

    /**
     * User must have the CUSTOM_USER_FIELDS[DELETE] permission to use this service
     * Delete a Custom User Field
     */
    async deleteCustomUserFieldRaw(requestParameters: DeleteCustomUserFieldRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.key === null || requestParameters.key === undefined) {
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling deleteCustomUserField.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteCustomUserField.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/custom-user-fields/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters.key))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the CUSTOM_USER_FIELDS[DELETE] permission to use this service
     * Delete a Custom User Field
     */
    async deleteCustomUserField(requestParameters: DeleteCustomUserFieldRequest): Promise<void> {
        await this.deleteCustomUserFieldRaw(requestParameters);
    }

    /**
     * User must have the MANAGEMENT_DASHBOARD[DELETE] permission to use this service
     * Delete a platform dashboard
     */
    async deleteDashboardRaw(requestParameters: DeleteDashboardRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.dashboardId === null || requestParameters.dashboardId === undefined) {
            throw new runtime.RequiredError('dashboardId','Required parameter requestParameters.dashboardId was null or undefined when calling deleteDashboard.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteDashboard.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteDashboard.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dashboards/{dashboardId}`.replace(`{${"dashboardId"}}`, encodeURIComponent(String(requestParameters.dashboardId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGEMENT_DASHBOARD[DELETE] permission to use this service
     * Delete a platform dashboard
     */
    async deleteDashboard(requestParameters: DeleteDashboardRequest): Promise<void> {
        await this.deleteDashboardRaw(requestParameters);
    }

    /**
     * User must have the DICTIONARY[DELETE] permission to use this service
     * Delete a dictionary
     */
    async deleteDictionaryRaw(requestParameters: DeleteDictionaryRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
            throw new runtime.RequiredError('dictionary','Required parameter requestParameters.dictionary was null or undefined when calling deleteDictionary.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteDictionary.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteDictionary.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries/{dictionary}`.replace(`{${"dictionary"}}`, encodeURIComponent(String(requestParameters.dictionary))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the DICTIONARY[DELETE] permission to use this service
     * Delete a dictionary
     */
    async deleteDictionary(requestParameters: DeleteDictionaryRequest): Promise<void> {
        await this.deleteDictionaryRaw(requestParameters);
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[DELETE] permission to use this service
     * Delete a platform entrypoint
     */
    async deleteEntrypointRaw(requestParameters: DeleteEntrypointRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.entrypoint === null || requestParameters.entrypoint === undefined) {
            throw new runtime.RequiredError('entrypoint','Required parameter requestParameters.entrypoint was null or undefined when calling deleteEntrypoint.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteEntrypoint.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/entrypoints/{entrypoint}`.replace(`{${"entrypoint"}}`, encodeURIComponent(String(requestParameters.entrypoint))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[DELETE] permission to use this service
     * Delete a platform entrypoint
     */
    async deleteEntrypoint(requestParameters: DeleteEntrypointRequest): Promise<void> {
        await this.deleteEntrypointRaw(requestParameters);
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[DELETE] permission to use this service
     * Delete a platform entrypoint
     */
    async deleteEntrypoint1Raw(requestParameters: DeleteEntrypoint1Request): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.entrypoint === null || requestParameters.entrypoint === undefined) {
            throw new runtime.RequiredError('entrypoint','Required parameter requestParameters.entrypoint was null or undefined when calling deleteEntrypoint1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteEntrypoint1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteEntrypoint1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/entrypoints/{entrypoint}`.replace(`{${"entrypoint"}}`, encodeURIComponent(String(requestParameters.entrypoint))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[DELETE] permission to use this service
     * Delete a platform entrypoint
     */
    async deleteEntrypoint1(requestParameters: DeleteEntrypoint1Request): Promise<void> {
        await this.deleteEntrypoint1Raw(requestParameters);
    }

    /**
     * Delete an existing group
     */
    async deleteGroupRaw(requestParameters: DeleteGroupRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling deleteGroup.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteGroup.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteGroup.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups/{group}`.replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an existing group
     */
    async deleteGroup(requestParameters: DeleteGroupRequest): Promise<void> {
        await this.deleteGroupRaw(requestParameters);
    }

    /**
     * User must have the GROUP_INVITATION[DELETE] permission to use this service
     * Delete an invitation to join a group
     */
    async deleteGroupInvitationRaw(requestParameters: DeleteGroupInvitationRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.invitation === null || requestParameters.invitation === undefined) {
            throw new runtime.RequiredError('invitation','Required parameter requestParameters.invitation was null or undefined when calling deleteGroupInvitation.');
        }

        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling deleteGroupInvitation.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteGroupInvitation.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteGroupInvitation.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups/{group}/invitations/{invitation}`.replace(`{${"invitation"}}`, encodeURIComponent(String(requestParameters.invitation))).replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the GROUP_INVITATION[DELETE] permission to use this service
     * Delete an invitation to join a group
     */
    async deleteGroupInvitation(requestParameters: DeleteGroupInvitationRequest): Promise<void> {
        await this.deleteGroupInvitationRaw(requestParameters);
    }

    /**
     * Remove a group member
     */
    async deleteGroupMemberRaw(requestParameters: DeleteGroupMemberRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.member === null || requestParameters.member === undefined) {
            throw new runtime.RequiredError('member','Required parameter requestParameters.member was null or undefined when calling deleteGroupMember.');
        }

        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling deleteGroupMember.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteGroupMember.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteGroupMember.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups/{group}/members/{member}`.replace(`{${"member"}}`, encodeURIComponent(String(requestParameters.member))).replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a group member
     */
    async deleteGroupMember(requestParameters: DeleteGroupMemberRequest): Promise<void> {
        await this.deleteGroupMemberRaw(requestParameters);
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[DELETE] permission to use this service
     * Delete an identity provider
     */
    async deleteIdentityProviderRaw(requestParameters: DeleteIdentityProviderRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.identityProvider === null || requestParameters.identityProvider === undefined) {
            throw new runtime.RequiredError('identityProvider','Required parameter requestParameters.identityProvider was null or undefined when calling deleteIdentityProvider.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteIdentityProvider.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/identities/{identityProvider}`.replace(`{${"identityProvider"}}`, encodeURIComponent(String(requestParameters.identityProvider))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[DELETE] permission to use this service
     * Delete an identity provider
     */
    async deleteIdentityProvider(requestParameters: DeleteIdentityProviderRequest): Promise<void> {
        await this.deleteIdentityProviderRaw(requestParameters);
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[DELETE] permission to use this service
     * Delete an identity provider
     */
    async deleteIdentityProvider1Raw(requestParameters: DeleteIdentityProvider1Request): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.identityProvider === null || requestParameters.identityProvider === undefined) {
            throw new runtime.RequiredError('identityProvider','Required parameter requestParameters.identityProvider was null or undefined when calling deleteIdentityProvider1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteIdentityProvider1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteIdentityProvider1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/identities/{identityProvider}`.replace(`{${"identityProvider"}}`, encodeURIComponent(String(requestParameters.identityProvider))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[DELETE] permission to use this service
     * Delete an identity provider
     */
    async deleteIdentityProvider1(requestParameters: DeleteIdentityProvider1Request): Promise<void> {
        await this.deleteIdentityProvider1Raw(requestParameters);
    }

    /**
     * User must have the PORTAL_METADATA[DELETE] permission to use this service
     * Delete a platform metadata
     */
    async deleteMetadataRaw(requestParameters: DeleteMetadataRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.metadata === null || requestParameters.metadata === undefined) {
            throw new runtime.RequiredError('metadata','Required parameter requestParameters.metadata was null or undefined when calling deleteMetadata.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteMetadata.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteMetadata.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/metadata/{metadata}`.replace(`{${"metadata"}}`, encodeURIComponent(String(requestParameters.metadata))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the PORTAL_METADATA[DELETE] permission to use this service
     * Delete a platform metadata
     */
    async deleteMetadata(requestParameters: DeleteMetadataRequest): Promise<void> {
        await this.deleteMetadataRaw(requestParameters);
    }

    /**
     * Delete notification settings
     */
    async deleteNotificationSettingsRaw(requestParameters: DeleteNotificationSettingsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.notificationId === null || requestParameters.notificationId === undefined) {
            throw new runtime.RequiredError('notificationId','Required parameter requestParameters.notificationId was null or undefined when calling deleteNotificationSettings.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteNotificationSettings.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteNotificationSettings.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/notificationsettings/{notificationId}`.replace(`{${"notificationId"}}`, encodeURIComponent(String(requestParameters.notificationId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete notification settings
     */
    async deleteNotificationSettings(requestParameters: DeleteNotificationSettingsRequest): Promise<void> {
        await this.deleteNotificationSettingsRaw(requestParameters);
    }

    /**
     * User must have the MANAGEMENT_QUALITY_RULE[READ] permission to use this service
     * Delete a quality rule
     */
    async deleteQualityRuleRaw(requestParameters: DeleteQualityRuleRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteQualityRule.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteQualityRule.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteQualityRule.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/quality-rules/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGEMENT_QUALITY_RULE[READ] permission to use this service
     * Delete a quality rule
     */
    async deleteQualityRule(requestParameters: DeleteQualityRuleRequest): Promise<void> {
        await this.deleteQualityRuleRaw(requestParameters);
    }

    /**
     * User must have the MANAGEMENT_ROLE[DELETE] permission to use this service
     * Delete a role
     */
    async deleteRoleRaw(requestParameters: DeleteRoleRequest): Promise<runtime.ApiResponse<RoleEntity>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling deleteRole.');
        }

        if (requestParameters.role === null || requestParameters.role === undefined) {
            throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling deleteRole.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteRole.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/rolescopes/{scope}/roles/{role}`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"role"}}`, encodeURIComponent(String(requestParameters.role))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ROLE[DELETE] permission to use this service
     * Delete a role
     */
    async deleteRole(requestParameters: DeleteRoleRequest): Promise<RoleEntity> {
        const response = await this.deleteRoleRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ROLE[DELETE] permission to use this service
     * Delete a role
     */
    async deleteRole1Raw(requestParameters: DeleteRole1Request): Promise<runtime.ApiResponse<RoleEntity>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling deleteRole1.');
        }

        if (requestParameters.role === null || requestParameters.role === undefined) {
            throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling deleteRole1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteRole1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteRole1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/rolescopes/{scope}/roles/{role}`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"role"}}`, encodeURIComponent(String(requestParameters.role))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ROLE[DELETE] permission to use this service
     * Delete a role
     */
    async deleteRole1(requestParameters: DeleteRole1Request): Promise<RoleEntity> {
        const response = await this.deleteRole1Raw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ROLE[DELETE] permission to use this service
     * Delete the role for a given user
     */
    async deleteRoleForUserRaw(requestParameters: DeleteRoleForUserRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling deleteRoleForUser.');
        }

        if (requestParameters.role === null || requestParameters.role === undefined) {
            throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling deleteRoleForUser.');
        }

        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteRoleForUser.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteRoleForUser.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/rolescopes/{scope}/roles/{role}/users/{userId}`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"role"}}`, encodeURIComponent(String(requestParameters.role))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGEMENT_ROLE[DELETE] permission to use this service
     * Delete the role for a given user
     */
    async deleteRoleForUser(requestParameters: DeleteRoleForUserRequest): Promise<void> {
        await this.deleteRoleForUserRaw(requestParameters);
    }

    /**
     * User must have the MANAGEMENT_ROLE[DELETE] permission to use this service
     * Delete the role for a given user
     */
    async deleteRoleForUser1Raw(requestParameters: DeleteRoleForUser1Request): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling deleteRoleForUser1.');
        }

        if (requestParameters.role === null || requestParameters.role === undefined) {
            throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling deleteRoleForUser1.');
        }

        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteRoleForUser1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteRoleForUser1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteRoleForUser1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/rolescopes/{scope}/roles/{role}/users/{userId}`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"role"}}`, encodeURIComponent(String(requestParameters.role))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGEMENT_ROLE[DELETE] permission to use this service
     * Delete the role for a given user
     */
    async deleteRoleForUser1(requestParameters: DeleteRoleForUser1Request): Promise<void> {
        await this.deleteRoleForUser1Raw(requestParameters);
    }

    /**
     * User must have the MANAGEMENT_TAG[DELETE] permission to use this service
     * Delete an existing sharding tag
     */
    async deleteTagRaw(requestParameters: DeleteTagRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.tag === null || requestParameters.tag === undefined) {
            throw new runtime.RequiredError('tag','Required parameter requestParameters.tag was null or undefined when calling deleteTag.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteTag.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/tags/{tag}`.replace(`{${"tag"}}`, encodeURIComponent(String(requestParameters.tag))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGEMENT_TAG[DELETE] permission to use this service
     * Delete an existing sharding tag
     */
    async deleteTag(requestParameters: DeleteTagRequest): Promise<void> {
        await this.deleteTagRaw(requestParameters);
    }

    /**
     * User must have the MANAGEMENT_TAG[DELETE] permission to use this service
     * Delete an existing sharding tag
     */
    async deleteTag1Raw(requestParameters: DeleteTag1Request): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.tag === null || requestParameters.tag === undefined) {
            throw new runtime.RequiredError('tag','Required parameter requestParameters.tag was null or undefined when calling deleteTag1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteTag1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteTag1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/tags/{tag}`.replace(`{${"tag"}}`, encodeURIComponent(String(requestParameters.tag))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGEMENT_TAG[DELETE] permission to use this service
     * Delete an existing sharding tag
     */
    async deleteTag1(requestParameters: DeleteTag1Request): Promise<void> {
        await this.deleteTag1Raw(requestParameters);
    }

    /**
     * User must have the MANAGEMENT_TENANT[DELETE] permission to use this service
     * Delete a tenant
     */
    async deleteTenantRaw(requestParameters: DeleteTenantRequest): Promise<runtime.ApiResponse<Array<TenantEntity>>> {
        if (requestParameters.tenant === null || requestParameters.tenant === undefined) {
            throw new runtime.RequiredError('tenant','Required parameter requestParameters.tenant was null or undefined when calling deleteTenant.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteTenant.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/tenants/{tenant}`.replace(`{${"tenant"}}`, encodeURIComponent(String(requestParameters.tenant))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TenantEntityFromJSON));
    }

    /**
     * User must have the MANAGEMENT_TENANT[DELETE] permission to use this service
     * Delete a tenant
     */
    async deleteTenant(requestParameters: DeleteTenantRequest): Promise<Array<TenantEntity>> {
        const response = await this.deleteTenantRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_TENANT[DELETE] permission to use this service
     * Delete a tenant
     */
    async deleteTenant1Raw(requestParameters: DeleteTenant1Request): Promise<runtime.ApiResponse<Array<TenantEntity>>> {
        if (requestParameters.tenant === null || requestParameters.tenant === undefined) {
            throw new runtime.RequiredError('tenant','Required parameter requestParameters.tenant was null or undefined when calling deleteTenant1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteTenant1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteTenant1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/tenants/{tenant}`.replace(`{${"tenant"}}`, encodeURIComponent(String(requestParameters.tenant))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TenantEntityFromJSON));
    }

    /**
     * User must have the MANAGEMENT_TENANT[DELETE] permission to use this service
     * Delete a tenant
     */
    async deleteTenant1(requestParameters: DeleteTenant1Request): Promise<Array<TenantEntity>> {
        const response = await this.deleteTenant1Raw(requestParameters);
        return await response.value();
    }

    /**
     */
    async deleteThemeRaw(requestParameters: DeleteThemeRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.themeId === null || requestParameters.themeId === undefined) {
            throw new runtime.RequiredError('themeId','Required parameter requestParameters.themeId was null or undefined when calling deleteTheme.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteTheme.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteTheme.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/themes/{themeId}`.replace(`{${"themeId"}}`, encodeURIComponent(String(requestParameters.themeId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteTheme(requestParameters: DeleteThemeRequest): Promise<void> {
        await this.deleteThemeRaw(requestParameters);
    }

    /**
     * User must have the PORTAL_TOP_APIS[DELETE] permission to use this service
     * Delete an existing top API
     */
    async deleteTopApiRaw(requestParameters: DeleteTopApiRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.topAPI === null || requestParameters.topAPI === undefined) {
            throw new runtime.RequiredError('topAPI','Required parameter requestParameters.topAPI was null or undefined when calling deleteTopApi.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteTopApi.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteTopApi.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/top-apis/{topAPI}`.replace(`{${"topAPI"}}`, encodeURIComponent(String(requestParameters.topAPI))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the PORTAL_TOP_APIS[DELETE] permission to use this service
     * Delete an existing top API
     */
    async deleteTopApi(requestParameters: DeleteTopApiRequest): Promise<void> {
        await this.deleteTopApiRaw(requestParameters);
    }

    /**
     * User must have the DICTIONARY[UPDATE] permission to use this service
     * Deploy dictionary to API gateway
     */
    async deployDictionaryRaw(requestParameters: DeployDictionaryRequest): Promise<runtime.ApiResponse<DictionaryEntity>> {
        if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
            throw new runtime.RequiredError('dictionary','Required parameter requestParameters.dictionary was null or undefined when calling deployDictionary.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deployDictionary.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deployDictionary.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries/{dictionary}/_deploy`.replace(`{${"dictionary"}}`, encodeURIComponent(String(requestParameters.dictionary))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DictionaryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the DICTIONARY[UPDATE] permission to use this service
     * Deploy dictionary to API gateway
     */
    async deployDictionary(requestParameters: DeployDictionaryRequest): Promise<DictionaryEntity> {
        const response = await this.deployDictionaryRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the DICTIONARY[LIFECYCLE] permission to use this service
     * Manage the dictionary\'s lifecycle
     */
    async doLifecycleActionRaw(requestParameters: DoLifecycleActionRequest): Promise<runtime.ApiResponse<DictionaryEntity>> {
        if (requestParameters.action === null || requestParameters.action === undefined) {
            throw new runtime.RequiredError('action','Required parameter requestParameters.action was null or undefined when calling doLifecycleAction.');
        }

        if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
            throw new runtime.RequiredError('dictionary','Required parameter requestParameters.dictionary was null or undefined when calling doLifecycleAction.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling doLifecycleAction.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling doLifecycleAction.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.action !== undefined) {
            queryParameters['action'] = requestParameters.action;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries/{dictionary}`.replace(`{${"dictionary"}}`, encodeURIComponent(String(requestParameters.dictionary))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DictionaryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the DICTIONARY[LIFECYCLE] permission to use this service
     * Manage the dictionary\'s lifecycle
     */
    async doLifecycleAction(requestParameters: DoLifecycleActionRequest): Promise<DictionaryEntity> {
        const response = await this.doLifecycleActionRaw(requestParameters);
        return await response.value();
    }

    /**
     * List API headers
     */
    async getApiHeadersRaw(requestParameters: GetApiHeadersRequest): Promise<runtime.ApiResponse<Array<ApiHeaderEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiHeaders.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiHeaders.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/apiheaders`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ApiHeaderEntityFromJSON));
    }

    /**
     * List API headers
     */
    async getApiHeaders(requestParameters: GetApiHeadersRequest): Promise<Array<ApiHeaderEntity>> {
        const response = await this.getApiHeadersRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve list of categories
     */
    async getCategoriesRaw(requestParameters: GetCategoriesRequest): Promise<runtime.ApiResponse<Array<CategoryEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getCategories.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getCategories.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/categories`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CategoryEntityFromJSON));
    }

    /**
     * Retrieve list of categories
     */
    async getCategories(requestParameters: GetCategoriesRequest): Promise<Array<CategoryEntity>> {
        const response = await this.getCategoriesRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_CATEGORY[READ] permission to use this service
     * Get the category
     */
    async getCategoryRaw(requestParameters: GetCategoryRequest): Promise<runtime.ApiResponse<CategoryEntity>> {
        if (requestParameters.categoryId === null || requestParameters.categoryId === undefined) {
            throw new runtime.RequiredError('categoryId','Required parameter requestParameters.categoryId was null or undefined when calling getCategory.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getCategory.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getCategory.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/categories/{categoryId}`.replace(`{${"categoryId"}}`, encodeURIComponent(String(requestParameters.categoryId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CategoryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the PORTAL_CATEGORY[READ] permission to use this service
     * Get the category
     */
    async getCategory(requestParameters: GetCategoryRequest): Promise<CategoryEntity> {
        const response = await this.getCategoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the READ permission to use this service
     * Get the Category\'s background
     */
    async getCategoryBackgroundRaw(requestParameters: GetCategoryBackgroundRequest): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.categoryId === null || requestParameters.categoryId === undefined) {
            throw new runtime.RequiredError('categoryId','Required parameter requestParameters.categoryId was null or undefined when calling getCategoryBackground.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getCategoryBackground.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getCategoryBackground.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/categories/{categoryId}/background`.replace(`{${"categoryId"}}`, encodeURIComponent(String(requestParameters.categoryId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * User must have the READ permission to use this service
     * Get the Category\'s background
     */
    async getCategoryBackground(requestParameters: GetCategoryBackgroundRequest): Promise<Blob> {
        const response = await this.getCategoryBackgroundRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_CATEGORY[READ] permission to use this service
     * Get the category\'s picture
     */
    async getCategoryPictureRaw(requestParameters: GetCategoryPictureRequest): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.categoryId === null || requestParameters.categoryId === undefined) {
            throw new runtime.RequiredError('categoryId','Required parameter requestParameters.categoryId was null or undefined when calling getCategoryPicture.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getCategoryPicture.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getCategoryPicture.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/categories/{categoryId}/picture`.replace(`{${"categoryId"}}`, encodeURIComponent(String(requestParameters.categoryId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * User must have the PORTAL_CATEGORY[READ] permission to use this service
     * Get the category\'s picture
     */
    async getCategoryPicture(requestParameters: GetCategoryPictureRequest): Promise<Blob> {
        const response = await this.getCategoryPictureRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_CLIENT_REGISTRATION_PROVIDER[READ] permission to use this service
     * Get a client registration provider
     */
    async getClientRegistrationProviderRaw(requestParameters: GetClientRegistrationProviderRequest): Promise<runtime.ApiResponse<ClientRegistrationProviderEntity>> {
        if (requestParameters.clientRegistrationProvider === null || requestParameters.clientRegistrationProvider === undefined) {
            throw new runtime.RequiredError('clientRegistrationProvider','Required parameter requestParameters.clientRegistrationProvider was null or undefined when calling getClientRegistrationProvider.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getClientRegistrationProvider.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getClientRegistrationProvider.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/applications/registration/providers/{clientRegistrationProvider}`.replace(`{${"clientRegistrationProvider"}}`, encodeURIComponent(String(requestParameters.clientRegistrationProvider))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ClientRegistrationProviderEntityFromJSON(jsonValue));
    }

    /**
     * User must have the PORTAL_CLIENT_REGISTRATION_PROVIDER[READ] permission to use this service
     * Get a client registration provider
     */
    async getClientRegistrationProvider(requestParameters: GetClientRegistrationProviderRequest): Promise<ClientRegistrationProviderEntity> {
        const response = await this.getClientRegistrationProviderRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_CLIENT_REGISTRATION_PROVIDER[READ] permission to use this service
     * Get the list of client registration providers
     */
    async getClientRegistrationProvidersRaw(requestParameters: GetClientRegistrationProvidersRequest): Promise<runtime.ApiResponse<Array<ClientRegistrationProviderListItem>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getClientRegistrationProviders.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getClientRegistrationProviders.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/applications/registration/providers`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClientRegistrationProviderListItemFromJSON));
    }

    /**
     * User must have the PORTAL_CLIENT_REGISTRATION_PROVIDER[READ] permission to use this service
     * Get the list of client registration providers
     */
    async getClientRegistrationProviders(requestParameters: GetClientRegistrationProvidersRequest): Promise<Array<ClientRegistrationProviderListItem>> {
        const response = await this.getClientRegistrationProvidersRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the list of available hooks
     */
    async getConfigurationHooksRaw(requestParameters: GetConfigurationHooksRequest): Promise<runtime.ApiResponse<Array<Hook>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getConfigurationHooks.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getConfigurationHooks.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/hooks`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(HookFromJSON));
    }

    /**
     * Get the list of available hooks
     */
    async getConfigurationHooks(requestParameters: GetConfigurationHooksRequest): Promise<Array<Hook>> {
        const response = await this.getConfigurationHooksRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async getConfigurationSchemaFormRaw(requestParameters: GetConfigurationSchemaFormRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getConfigurationSchemaForm.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/flows/configuration-schema`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async getConfigurationSchemaForm(requestParameters: GetConfigurationSchemaFormRequest): Promise<void> {
        await this.getConfigurationSchemaFormRaw(requestParameters);
    }

    /**
     * User must have the CUSTOM_USER_FIELDS[READ] permission to use this service
     * List All Custom User Fields
     */
    async getCustomUserFieldsRaw(requestParameters: GetCustomUserFieldsRequest): Promise<runtime.ApiResponse<Array<CustomUserFieldEntity>>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getCustomUserFields.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/custom-user-fields`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomUserFieldEntityFromJSON));
    }

    /**
     * User must have the CUSTOM_USER_FIELDS[READ] permission to use this service
     * List All Custom User Fields
     */
    async getCustomUserFields(requestParameters: GetCustomUserFieldsRequest): Promise<Array<CustomUserFieldEntity>> {
        const response = await this.getCustomUserFieldsRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_DASHBOARD[READ] permission to use this service
     * Retrieve a platform dashboard
     */
    async getDashboardRaw(requestParameters: GetDashboardRequest): Promise<runtime.ApiResponse<DashboardEntity>> {
        if (requestParameters.dashboardId === null || requestParameters.dashboardId === undefined) {
            throw new runtime.RequiredError('dashboardId','Required parameter requestParameters.dashboardId was null or undefined when calling getDashboard.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getDashboard.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getDashboard.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dashboards/{dashboardId}`.replace(`{${"dashboardId"}}`, encodeURIComponent(String(requestParameters.dashboardId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DashboardEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_DASHBOARD[READ] permission to use this service
     * Retrieve a platform dashboard
     */
    async getDashboard(requestParameters: GetDashboardRequest): Promise<DashboardEntity> {
        const response = await this.getDashboardRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve the list of platform dashboards
     */
    async getDashboardsRaw(requestParameters: GetDashboardsRequest): Promise<runtime.ApiResponse<Array<DashboardEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getDashboards.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getDashboards.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.referenceType !== undefined) {
            queryParameters['reference_type'] = requestParameters.referenceType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dashboards`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DashboardEntityFromJSON));
    }

    /**
     * Retrieve the list of platform dashboards
     */
    async getDashboards(requestParameters: GetDashboardsRequest): Promise<Array<DashboardEntity>> {
        const response = await this.getDashboardsRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the DICTIONARY[READ] permission to use this service
     * Get the list of global dictionaries
     */
    async getDictionariesRaw(requestParameters: GetDictionariesRequest): Promise<runtime.ApiResponse<Array<DictionaryListItem>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getDictionaries.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getDictionaries.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DictionaryListItemFromJSON));
    }

    /**
     * User must have the DICTIONARY[READ] permission to use this service
     * Get the list of global dictionaries
     */
    async getDictionaries(requestParameters: GetDictionariesRequest): Promise<Array<DictionaryListItem>> {
        const response = await this.getDictionariesRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the DICTIONARY[READ] permission to use this service
     * Get a dictionary
     */
    async getDictionaryRaw(requestParameters: GetDictionaryRequest): Promise<runtime.ApiResponse<DictionaryEntity>> {
        if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
            throw new runtime.RequiredError('dictionary','Required parameter requestParameters.dictionary was null or undefined when calling getDictionary.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getDictionary.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getDictionary.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries/{dictionary}`.replace(`{${"dictionary"}}`, encodeURIComponent(String(requestParameters.dictionary))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DictionaryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the DICTIONARY[READ] permission to use this service
     * Get a dictionary
     */
    async getDictionary(requestParameters: GetDictionaryRequest): Promise<DictionaryEntity> {
        const response = await this.getDictionaryRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the list of enabled application types
     */
    async getEnabledApplicationTypesRaw(requestParameters: GetEnabledApplicationTypesRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getEnabledApplicationTypes.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getEnabledApplicationTypes.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/applications/types`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get the list of enabled application types
     */
    async getEnabledApplicationTypes(requestParameters: GetEnabledApplicationTypesRequest): Promise<void> {
        await this.getEnabledApplicationTypesRaw(requestParameters);
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[READ] permission to use this service
     * Get a platform entrypoints
     */
    async getEntrypointRaw(requestParameters: GetEntrypointRequest): Promise<runtime.ApiResponse<EntrypointEntity>> {
        if (requestParameters.entrypoint === null || requestParameters.entrypoint === undefined) {
            throw new runtime.RequiredError('entrypoint','Required parameter requestParameters.entrypoint was null or undefined when calling getEntrypoint.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getEntrypoint.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/entrypoints/{entrypoint}`.replace(`{${"entrypoint"}}`, encodeURIComponent(String(requestParameters.entrypoint))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EntrypointEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[READ] permission to use this service
     * Get a platform entrypoints
     */
    async getEntrypoint(requestParameters: GetEntrypointRequest): Promise<EntrypointEntity> {
        const response = await this.getEntrypointRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[READ] permission to use this service
     * Get a platform entrypoints
     */
    async getEntrypoint1Raw(requestParameters: GetEntrypoint1Request): Promise<runtime.ApiResponse<EntrypointEntity>> {
        if (requestParameters.entrypoint === null || requestParameters.entrypoint === undefined) {
            throw new runtime.RequiredError('entrypoint','Required parameter requestParameters.entrypoint was null or undefined when calling getEntrypoint1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getEntrypoint1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getEntrypoint1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/entrypoints/{entrypoint}`.replace(`{${"entrypoint"}}`, encodeURIComponent(String(requestParameters.entrypoint))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EntrypointEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[READ] permission to use this service
     * Get a platform entrypoints
     */
    async getEntrypoint1(requestParameters: GetEntrypoint1Request): Promise<EntrypointEntity> {
        const response = await this.getEntrypoint1Raw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[READ] permission to use this service
     * List the platform entrypoints
     */
    async getEntrypointsRaw(requestParameters: GetEntrypointsRequest): Promise<runtime.ApiResponse<Array<EntrypointEntity>>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getEntrypoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/entrypoints`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EntrypointEntityFromJSON));
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[READ] permission to use this service
     * List the platform entrypoints
     */
    async getEntrypoints(requestParameters: GetEntrypointsRequest): Promise<Array<EntrypointEntity>> {
        const response = await this.getEntrypointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[READ] permission to use this service
     * List the platform entrypoints
     */
    async getEntrypoints1Raw(requestParameters: GetEntrypoints1Request): Promise<runtime.ApiResponse<Array<EntrypointEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getEntrypoints1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getEntrypoints1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/entrypoints`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EntrypointEntityFromJSON));
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[READ] permission to use this service
     * List the platform entrypoints
     */
    async getEntrypoints1(requestParameters: GetEntrypoints1Request): Promise<Array<EntrypointEntity>> {
        const response = await this.getEntrypoints1Raw(requestParameters);
        return await response.value();
    }

    /**
     */
    async getFaviconRaw(requestParameters: GetFaviconRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.themeId === null || requestParameters.themeId === undefined) {
            throw new runtime.RequiredError('themeId','Required parameter requestParameters.themeId was null or undefined when calling getFavicon.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getFavicon.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getFavicon.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/themes/{themeId}/favicon`.replace(`{${"themeId"}}`, encodeURIComponent(String(requestParameters.themeId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async getFavicon(requestParameters: GetFaviconRequest): Promise<void> {
        await this.getFaviconRaw(requestParameters);
    }

    /**
     */
    async getGrammarRaw(requestParameters: GetGrammarRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getGrammar.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getGrammar.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/spel/grammar`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async getGrammar(requestParameters: GetGrammarRequest): Promise<any> {
        const response = await this.getGrammarRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a group
     */
    async getGroupRaw(requestParameters: GetGroupRequest): Promise<runtime.ApiResponse<GroupEntity>> {
        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling getGroup.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getGroup.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getGroup.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups/{group}`.replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupEntityFromJSON(jsonValue));
    }

    /**
     * Get a group
     */
    async getGroup(requestParameters: GetGroupRequest): Promise<GroupEntity> {
        const response = await this.getGroupRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the GROUP_INVITATION[READ] permission to use this service
     * List existing invitations of a group
     */
    async getGroupInvitationsRaw(requestParameters: GetGroupInvitationsRequest): Promise<runtime.ApiResponse<Array<InvitationEntity>>> {
        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling getGroupInvitations.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getGroupInvitations.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getGroupInvitations.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups/{group}/invitations`.replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InvitationEntityFromJSON));
    }

    /**
     * User must have the GROUP_INVITATION[READ] permission to use this service
     * List existing invitations of a group
     */
    async getGroupInvitations(requestParameters: GetGroupInvitationsRequest): Promise<Array<InvitationEntity>> {
        const response = await this.getGroupInvitationsRaw(requestParameters);
        return await response.value();
    }

    /**
     * List group members
     */
    async getGroupMembersRaw(requestParameters: GetGroupMembersRequest): Promise<runtime.ApiResponse<Array<GroupMemberEntity>>> {
        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling getGroupMembers.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getGroupMembers.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getGroupMembers.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups/{group}/members`.replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GroupMemberEntityFromJSON));
    }

    /**
     * List group members
     */
    async getGroupMembers(requestParameters: GetGroupMembersRequest): Promise<Array<GroupMemberEntity>> {
        const response = await this.getGroupMembersRaw(requestParameters);
        return await response.value();
    }

    /**
     * List group members with pagination
     */
    async getGroupMembers1Raw(requestParameters: GetGroupMembers1Request): Promise<runtime.ApiResponse<Array<GroupMemberEntity>>> {
        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling getGroupMembers1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getGroupMembers1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getGroupMembers1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups/{group}/members/_paged`.replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GroupMemberEntityFromJSON));
    }

    /**
     * List group members with pagination
     */
    async getGroupMembers1(requestParameters: GetGroupMembers1Request): Promise<Array<GroupMemberEntity>> {
        const response = await this.getGroupMembers1Raw(requestParameters);
        return await response.value();
    }

    /**
     * List APIs or applications linked to this group
     */
    async getGroupMembershipsRaw(requestParameters: GetGroupMembershipsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling getGroupMemberships.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getGroupMemberships.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getGroupMemberships.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups/{group}/memberships`.replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * List APIs or applications linked to this group
     */
    async getGroupMemberships(requestParameters: GetGroupMembershipsRequest): Promise<void> {
        await this.getGroupMembershipsRaw(requestParameters);
    }

    /**
     * Find all groups, or a specific type of groups.Only administrators could see all groups.Only users with MANAGE_API permissions could see API groups.
     * Find groups
     */
    async getGroupsRaw(requestParameters: GetGroupsRequest): Promise<runtime.ApiResponse<Array<GroupEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getGroups.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getGroups.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GroupEntityFromJSON));
    }

    /**
     * Find all groups, or a specific type of groups.Only administrators could see all groups.Only users with MANAGE_API permissions could see API groups.
     * Find groups
     */
    async getGroups(requestParameters: GetGroupsRequest): Promise<Array<GroupEntity>> {
        const response = await this.getGroupsRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[READ] permission to use this service
     * Get an identity provider
     */
    async getIdentityProviderRaw(requestParameters: GetIdentityProviderRequest): Promise<runtime.ApiResponse<IdentityProviderEntity>> {
        if (requestParameters.identityProvider === null || requestParameters.identityProvider === undefined) {
            throw new runtime.RequiredError('identityProvider','Required parameter requestParameters.identityProvider was null or undefined when calling getIdentityProvider.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getIdentityProvider.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/identities/{identityProvider}`.replace(`{${"identityProvider"}}`, encodeURIComponent(String(requestParameters.identityProvider))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdentityProviderEntityFromJSON(jsonValue));
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[READ] permission to use this service
     * Get an identity provider
     */
    async getIdentityProvider(requestParameters: GetIdentityProviderRequest): Promise<IdentityProviderEntity> {
        const response = await this.getIdentityProviderRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[READ] permission to use this service
     * Get an identity provider
     */
    async getIdentityProvider1Raw(requestParameters: GetIdentityProvider1Request): Promise<runtime.ApiResponse<IdentityProviderEntity>> {
        if (requestParameters.identityProvider === null || requestParameters.identityProvider === undefined) {
            throw new runtime.RequiredError('identityProvider','Required parameter requestParameters.identityProvider was null or undefined when calling getIdentityProvider1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getIdentityProvider1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getIdentityProvider1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/identities/{identityProvider}`.replace(`{${"identityProvider"}}`, encodeURIComponent(String(requestParameters.identityProvider))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdentityProviderEntityFromJSON(jsonValue));
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[READ] permission to use this service
     * Get an identity provider
     */
    async getIdentityProvider1(requestParameters: GetIdentityProvider1Request): Promise<IdentityProviderEntity> {
        const response = await this.getIdentityProvider1Raw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[READ] permission to use this service
     * Get the list of identity providers
     */
    async getIdentityProvidersRaw(requestParameters: GetIdentityProvidersRequest): Promise<runtime.ApiResponse<Array<IdentityProviderListItem>>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getIdentityProviders.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/identities`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(IdentityProviderListItemFromJSON));
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[READ] permission to use this service
     * Get the list of identity providers
     */
    async getIdentityProviders(requestParameters: GetIdentityProvidersRequest): Promise<Array<IdentityProviderListItem>> {
        const response = await this.getIdentityProvidersRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[READ] permission to use this service
     * Get the list of identity providers
     */
    async getIdentityProviders1Raw(requestParameters: GetIdentityProviders1Request): Promise<runtime.ApiResponse<Array<IdentityProviderListItem>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getIdentityProviders1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getIdentityProviders1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/identities`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(IdentityProviderListItemFromJSON));
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[READ] permission to use this service
     * Get the list of identity providers
     */
    async getIdentityProviders1(requestParameters: GetIdentityProviders1Request): Promise<Array<IdentityProviderListItem>> {
        const response = await this.getIdentityProviders1Raw(requestParameters);
        return await response.value();
    }

    /**
     */
    async getLogoLightRaw(requestParameters: GetLogoLightRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.themeId === null || requestParameters.themeId === undefined) {
            throw new runtime.RequiredError('themeId','Required parameter requestParameters.themeId was null or undefined when calling getLogoLight.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getLogoLight.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getLogoLight.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/themes/{themeId}/optionalLogo`.replace(`{${"themeId"}}`, encodeURIComponent(String(requestParameters.themeId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async getLogoLight(requestParameters: GetLogoLightRequest): Promise<void> {
        await this.getLogoLightRaw(requestParameters);
    }

    /**
     * User must have the PORTAL_METADATA[READ] permission to use this service
     * Retrieve the list of platform metadata
     */
    async getMetadatasRaw(requestParameters: GetMetadatasRequest): Promise<runtime.ApiResponse<Array<MetadataEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getMetadatas.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getMetadatas.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/metadata`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MetadataEntityFromJSON));
    }

    /**
     * User must have the PORTAL_METADATA[READ] permission to use this service
     * Retrieve the list of platform metadata
     */
    async getMetadatas(requestParameters: GetMetadatasRequest): Promise<Array<MetadataEntity>> {
        const response = await this.getMetadatasRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the NOTIFICATION_TEMPLATES[READ] permission to use this service
     * Get a specific notification template.
     */
    async getNotificationTemplateRaw(requestParameters: GetNotificationTemplateRequest): Promise<runtime.ApiResponse<NotificationTemplateEntity>> {
        if (requestParameters.notificationTemplateId === null || requestParameters.notificationTemplateId === undefined) {
            throw new runtime.RequiredError('notificationTemplateId','Required parameter requestParameters.notificationTemplateId was null or undefined when calling getNotificationTemplate.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getNotificationTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/notification-templates/{notificationTemplateId}`.replace(`{${"notificationTemplateId"}}`, encodeURIComponent(String(requestParameters.notificationTemplateId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => NotificationTemplateEntityFromJSON(jsonValue));
    }

    /**
     * User must have the NOTIFICATION_TEMPLATES[READ] permission to use this service
     * Get a specific notification template.
     */
    async getNotificationTemplate(requestParameters: GetNotificationTemplateRequest): Promise<NotificationTemplateEntity> {
        const response = await this.getNotificationTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the NOTIFICATION_TEMPLATES[READ] permission to use this service
     * List all notification templates.
     */
    async getNotificationTemplatesRaw(requestParameters: GetNotificationTemplatesRequest): Promise<runtime.ApiResponse<Array<NotificationTemplateEntity>>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getNotificationTemplates.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.scope !== undefined) {
            queryParameters['scope'] = requestParameters.scope;
        }

        if (requestParameters.hook !== undefined) {
            queryParameters['hook'] = requestParameters.hook;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/notification-templates`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(NotificationTemplateEntityFromJSON));
    }

    /**
     * User must have the NOTIFICATION_TEMPLATES[READ] permission to use this service
     * List all notification templates.
     */
    async getNotificationTemplates(requestParameters: GetNotificationTemplatesRequest): Promise<Array<NotificationTemplateEntity>> {
        const response = await this.getNotificationTemplatesRaw(requestParameters);
        return await response.value();
    }

    /**
     * List of available plan\'s type
     */
    async getPlansConfigurationRaw(requestParameters: GetPlansConfigurationRequest): Promise<runtime.ApiResponse<PlansConfigurationEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getPlansConfiguration.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getPlansConfiguration.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/plans`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PlansConfigurationEntityFromJSON(jsonValue));
    }

    /**
     * List of available plan\'s type
     */
    async getPlansConfiguration(requestParameters: GetPlansConfigurationRequest): Promise<PlansConfigurationEntity> {
        const response = await this.getPlansConfigurationRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async getPlatformFlowSchemaFormRaw(requestParameters: GetPlatformFlowSchemaFormRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getPlatformFlowSchemaForm.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/flows/flow-schema`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async getPlatformFlowSchemaForm(requestParameters: GetPlatformFlowSchemaFormRequest): Promise<void> {
        await this.getPlatformFlowSchemaFormRaw(requestParameters);
    }

    /**
     * Get notification settings
     */
    async getPortalNotificationSettingsRaw(requestParameters: GetPortalNotificationSettingsRequest): Promise<runtime.ApiResponse<Array<any>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getPortalNotificationSettings.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getPortalNotificationSettings.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/notificationsettings`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get notification settings
     */
    async getPortalNotificationSettings(requestParameters: GetPortalNotificationSettingsRequest): Promise<Array<any>> {
        const response = await this.getPortalNotificationSettingsRaw(requestParameters);
        return await response.value();
    }

    /**
     * List of available notifiers
     */
    async getPortalNotifiersRaw(requestParameters: GetPortalNotifiersRequest): Promise<runtime.ApiResponse<Array<NotifierEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getPortalNotifiers.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getPortalNotifiers.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/notifiers`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(NotifierEntityFromJSON));
    }

    /**
     * List of available notifiers
     */
    async getPortalNotifiers(requestParameters: GetPortalNotifiersRequest): Promise<Array<NotifierEntity>> {
        const response = await this.getPortalNotifiersRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_QUALITY_RULE[READ] permission to use this service
     * Get a quality rule
     */
    async getQualityRuleRaw(requestParameters: GetQualityRuleRequest): Promise<runtime.ApiResponse<QualityRuleEntity>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getQualityRule.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getQualityRule.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getQualityRule.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/quality-rules/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => QualityRuleEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_QUALITY_RULE[READ] permission to use this service
     * Get a quality rule
     */
    async getQualityRule(requestParameters: GetQualityRuleRequest): Promise<QualityRuleEntity> {
        const response = await this.getQualityRuleRaw(requestParameters);
        return await response.value();
    }

    /**
     * List quality rules
     */
    async getQualityRulesRaw(requestParameters: GetQualityRulesRequest): Promise<runtime.ApiResponse<Array<QualityRuleEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getQualityRules.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getQualityRules.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/quality-rules`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(QualityRuleEntityFromJSON));
    }

    /**
     * List quality rules
     */
    async getQualityRules(requestParameters: GetQualityRulesRequest): Promise<Array<QualityRuleEntity>> {
        const response = await this.getQualityRulesRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ROLE[READ] permission to use this service
     * Get a role
     */
    async getRoleRaw(requestParameters: GetRoleRequest): Promise<runtime.ApiResponse<RoleEntity>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling getRole.');
        }

        if (requestParameters.role === null || requestParameters.role === undefined) {
            throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling getRole.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getRole.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/rolescopes/{scope}/roles/{role}`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"role"}}`, encodeURIComponent(String(requestParameters.role))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ROLE[READ] permission to use this service
     * Get a role
     */
    async getRole(requestParameters: GetRoleRequest): Promise<RoleEntity> {
        const response = await this.getRoleRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ROLE[READ] permission to use this service
     * Get a role
     */
    async getRole1Raw(requestParameters: GetRole1Request): Promise<runtime.ApiResponse<RoleEntity>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling getRole1.');
        }

        if (requestParameters.role === null || requestParameters.role === undefined) {
            throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling getRole1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getRole1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getRole1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/rolescopes/{scope}/roles/{role}`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"role"}}`, encodeURIComponent(String(requestParameters.role))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ROLE[READ] permission to use this service
     * Get a role
     */
    async getRole1(requestParameters: GetRole1Request): Promise<RoleEntity> {
        const response = await this.getRole1Raw(requestParameters);
        return await response.value();
    }

    /**
     * List availables role scopes
     */
    async getRoleScopesRaw(requestParameters: GetRoleScopesRequest): Promise<runtime.ApiResponse<{ [key: string]: Array<string>; }>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getRoleScopes.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/rolescopes`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * List availables role scopes
     */
    async getRoleScopes(requestParameters: GetRoleScopesRequest): Promise<{ [key: string]: Array<string>; }> {
        const response = await this.getRoleScopesRaw(requestParameters);
        return await response.value();
    }

    /**
     * List availables role scopes
     */
    async getRoleScopes1Raw(requestParameters: GetRoleScopes1Request): Promise<runtime.ApiResponse<{ [key: string]: Array<string>; }>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getRoleScopes1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getRoleScopes1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/rolescopes`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * List availables role scopes
     */
    async getRoleScopes1(requestParameters: GetRoleScopes1Request): Promise<{ [key: string]: Array<string>; }> {
        const response = await this.getRoleScopes1Raw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ROLE[READ] permission to use this service
     * List of roles
     */
    async getRolesRaw(requestParameters: GetRolesRequest): Promise<runtime.ApiResponse<Array<RoleEntity>>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling getRoles.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getRoles.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/rolescopes/{scope}/roles`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleEntityFromJSON));
    }

    /**
     * User must have the MANAGEMENT_ROLE[READ] permission to use this service
     * List of roles
     */
    async getRoles(requestParameters: GetRolesRequest): Promise<Array<RoleEntity>> {
        const response = await this.getRolesRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ROLE[READ] permission to use this service
     * List of roles
     */
    async getRoles1Raw(requestParameters: GetRoles1Request): Promise<runtime.ApiResponse<Array<RoleEntity>>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling getRoles1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getRoles1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getRoles1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/rolescopes/{scope}/roles`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleEntityFromJSON));
    }

    /**
     * User must have the MANAGEMENT_ROLE[READ] permission to use this service
     * List of roles
     */
    async getRoles1(requestParameters: GetRoles1Request): Promise<Array<RoleEntity>> {
        const response = await this.getRoles1Raw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_TAG[READ] permission to use this service
     * Get a sharding tag
     */
    async getTagRaw(requestParameters: GetTagRequest): Promise<runtime.ApiResponse<TagEntity>> {
        if (requestParameters.tag === null || requestParameters.tag === undefined) {
            throw new runtime.RequiredError('tag','Required parameter requestParameters.tag was null or undefined when calling getTag.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getTag.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/tags/{tag}`.replace(`{${"tag"}}`, encodeURIComponent(String(requestParameters.tag))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TagEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_TAG[READ] permission to use this service
     * Get a sharding tag
     */
    async getTag(requestParameters: GetTagRequest): Promise<TagEntity> {
        const response = await this.getTagRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_TAG[READ] permission to use this service
     * Get a sharding tag
     */
    async getTag1Raw(requestParameters: GetTag1Request): Promise<runtime.ApiResponse<TagEntity>> {
        if (requestParameters.tag === null || requestParameters.tag === undefined) {
            throw new runtime.RequiredError('tag','Required parameter requestParameters.tag was null or undefined when calling getTag1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getTag1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getTag1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/tags/{tag}`.replace(`{${"tag"}}`, encodeURIComponent(String(requestParameters.tag))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TagEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_TAG[READ] permission to use this service
     * Get a sharding tag
     */
    async getTag1(requestParameters: GetTag1Request): Promise<TagEntity> {
        const response = await this.getTag1Raw(requestParameters);
        return await response.value();
    }

    /**
     * List sharding tags
     */
    async getTagsRaw(requestParameters: GetTagsRequest): Promise<runtime.ApiResponse<Array<TagEntity>>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getTags.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/tags`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TagEntityFromJSON));
    }

    /**
     * List sharding tags
     */
    async getTags(requestParameters: GetTagsRequest): Promise<Array<TagEntity>> {
        const response = await this.getTagsRaw(requestParameters);
        return await response.value();
    }

    /**
     * List sharding tags
     */
    async getTags1Raw(requestParameters: GetTags1Request): Promise<runtime.ApiResponse<Array<TagEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getTags1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getTags1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/tags`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TagEntityFromJSON));
    }

    /**
     * List sharding tags
     */
    async getTags1(requestParameters: GetTags1Request): Promise<Array<TagEntity>> {
        const response = await this.getTags1Raw(requestParameters);
        return await response.value();
    }

    /**
     * List tenants
     */
    async getTenantsRaw(requestParameters: GetTenantsRequest): Promise<runtime.ApiResponse<Array<TenantEntity>>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getTenants.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/tenants`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TenantEntityFromJSON));
    }

    /**
     * List tenants
     */
    async getTenants(requestParameters: GetTenantsRequest): Promise<Array<TenantEntity>> {
        const response = await this.getTenantsRaw(requestParameters);
        return await response.value();
    }

    /**
     * List tenants
     */
    async getTenants1Raw(requestParameters: GetTenants1Request): Promise<runtime.ApiResponse<Array<TenantEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getTenants1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getTenants1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/tenants`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TenantEntityFromJSON));
    }

    /**
     * List tenants
     */
    async getTenants1(requestParameters: GetTenants1Request): Promise<Array<TenantEntity>> {
        const response = await this.getTenants1Raw(requestParameters);
        return await response.value();
    }

    /**
     */
    async getThemeRaw(requestParameters: GetThemeRequest): Promise<runtime.ApiResponse<ThemeEntity>> {
        if (requestParameters.themeId === null || requestParameters.themeId === undefined) {
            throw new runtime.RequiredError('themeId','Required parameter requestParameters.themeId was null or undefined when calling getTheme.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getTheme.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getTheme.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/themes/{themeId}`.replace(`{${"themeId"}}`, encodeURIComponent(String(requestParameters.themeId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ThemeEntityFromJSON(jsonValue));
    }

    /**
     */
    async getTheme(requestParameters: GetThemeRequest): Promise<ThemeEntity> {
        const response = await this.getThemeRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async getThemeBackgroundRaw(requestParameters: GetThemeBackgroundRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.themeId === null || requestParameters.themeId === undefined) {
            throw new runtime.RequiredError('themeId','Required parameter requestParameters.themeId was null or undefined when calling getThemeBackground.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getThemeBackground.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getThemeBackground.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/themes/{themeId}/backgroundImage`.replace(`{${"themeId"}}`, encodeURIComponent(String(requestParameters.themeId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async getThemeBackground(requestParameters: GetThemeBackgroundRequest): Promise<void> {
        await this.getThemeBackgroundRaw(requestParameters);
    }

    /**
     */
    async getThemeLogoRaw(requestParameters: GetThemeLogoRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.themeId === null || requestParameters.themeId === undefined) {
            throw new runtime.RequiredError('themeId','Required parameter requestParameters.themeId was null or undefined when calling getThemeLogo.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getThemeLogo.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getThemeLogo.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/themes/{themeId}/logo`.replace(`{${"themeId"}}`, encodeURIComponent(String(requestParameters.themeId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async getThemeLogo(requestParameters: GetThemeLogoRequest): Promise<void> {
        await this.getThemeLogoRaw(requestParameters);
    }

    /**
     * User must have the PORTAL_TOP_APIS[READ] permission to use this service
     * List of top APIs
     */
    async getTopApisRaw(requestParameters: GetTopApisRequest): Promise<runtime.ApiResponse<Array<TopApiEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getTopApis.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getTopApis.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/top-apis`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TopApiEntityFromJSON));
    }

    /**
     * User must have the PORTAL_TOP_APIS[READ] permission to use this service
     * List of top APIs
     */
    async getTopApis(requestParameters: GetTopApisRequest): Promise<Array<TopApiEntity>> {
        const response = await this.getTopApisRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ROLE[READ] permission to use this service
     * List users with the given role
     */
    async getUsersPerRoleRaw(requestParameters: GetUsersPerRoleRequest): Promise<runtime.ApiResponse<Array<MembershipListItem>>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling getUsersPerRole.');
        }

        if (requestParameters.role === null || requestParameters.role === undefined) {
            throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling getUsersPerRole.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getUsersPerRole.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/rolescopes/{scope}/roles/{role}/users`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"role"}}`, encodeURIComponent(String(requestParameters.role))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MembershipListItemFromJSON));
    }

    /**
     * User must have the MANAGEMENT_ROLE[READ] permission to use this service
     * List users with the given role
     */
    async getUsersPerRole(requestParameters: GetUsersPerRoleRequest): Promise<Array<MembershipListItem>> {
        const response = await this.getUsersPerRoleRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ROLE[READ] permission to use this service
     * List users with the given role
     */
    async getUsersPerRole1Raw(requestParameters: GetUsersPerRole1Request): Promise<runtime.ApiResponse<Array<MembershipListItem>>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling getUsersPerRole1.');
        }

        if (requestParameters.role === null || requestParameters.role === undefined) {
            throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling getUsersPerRole1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getUsersPerRole1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getUsersPerRole1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/rolescopes/{scope}/roles/{role}/users`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"role"}}`, encodeURIComponent(String(requestParameters.role))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MembershipListItemFromJSON));
    }

    /**
     * User must have the MANAGEMENT_ROLE[READ] permission to use this service
     * List users with the given role
     */
    async getUsersPerRole1(requestParameters: GetUsersPerRole1Request): Promise<Array<MembershipListItem>> {
        const response = await this.getUsersPerRole1Raw(requestParameters);
        return await response.value();
    }

    /**
     * Get the global flow configuration of the organization
     */
    async hasPoliciesRaw(requestParameters: HasPoliciesRequest): Promise<runtime.ApiResponse<OrganizationFlowConfiguration>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling hasPolicies.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/flows`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OrganizationFlowConfigurationFromJSON(jsonValue));
    }

    /**
     * Get the global flow configuration of the organization
     */
    async hasPolicies(requestParameters: HasPoliciesRequest): Promise<OrganizationFlowConfiguration> {
        const response = await this.hasPoliciesRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async resetThemeRaw(requestParameters: ResetThemeRequest): Promise<runtime.ApiResponse<ThemeEntity>> {
        if (requestParameters.themeId === null || requestParameters.themeId === undefined) {
            throw new runtime.RequiredError('themeId','Required parameter requestParameters.themeId was null or undefined when calling resetTheme.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling resetTheme.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling resetTheme.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/themes/{themeId}/reset`.replace(`{${"themeId"}}`, encodeURIComponent(String(requestParameters.themeId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ThemeEntityFromJSON(jsonValue));
    }

    /**
     */
    async resetTheme(requestParameters: ResetThemeRequest): Promise<ThemeEntity> {
        const response = await this.resetThemeRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the DICTIONARY[UPDATE] permission to use this service
     * Undeploy dictionary to API gateway
     */
    async undeployDictionaryRaw(requestParameters: UndeployDictionaryRequest): Promise<runtime.ApiResponse<DictionaryEntity>> {
        if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
            throw new runtime.RequiredError('dictionary','Required parameter requestParameters.dictionary was null or undefined when calling undeployDictionary.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling undeployDictionary.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling undeployDictionary.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries/{dictionary}/_undeploy`.replace(`{${"dictionary"}}`, encodeURIComponent(String(requestParameters.dictionary))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DictionaryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the DICTIONARY[UPDATE] permission to use this service
     * Undeploy dictionary to API gateway
     */
    async undeployDictionary(requestParameters: UndeployDictionaryRequest): Promise<DictionaryEntity> {
        const response = await this.undeployDictionaryRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_API_HEADER[UPDATE] permission to use this service
     * Update an API header
     */
    async updateApiHeaderRaw(requestParameters: UpdateApiHeaderRequest): Promise<runtime.ApiResponse<ApiHeaderEntity>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateApiHeader.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiHeader.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiHeader.');
        }

        if (requestParameters.updateApiHeaderEntity === null || requestParameters.updateApiHeaderEntity === undefined) {
            throw new runtime.RequiredError('updateApiHeaderEntity','Required parameter requestParameters.updateApiHeaderEntity was null or undefined when calling updateApiHeader.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/apiheaders/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateApiHeaderEntityToJSON(requestParameters.updateApiHeaderEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiHeaderEntityFromJSON(jsonValue));
    }

    /**
     * User must have the PORTAL_API_HEADER[UPDATE] permission to use this service
     * Update an API header
     */
    async updateApiHeader(requestParameters: UpdateApiHeaderRequest): Promise<ApiHeaderEntity> {
        const response = await this.updateApiHeaderRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_CATEGORY[UPDATE] permission to use this service
     * Update an existing category
     */
    async updateCategoriesRaw(requestParameters: UpdateCategoriesRequest): Promise<runtime.ApiResponse<Array<CategoryEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateCategories.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateCategories.');
        }

        if (requestParameters.updateCategoryEntity === null || requestParameters.updateCategoryEntity === undefined) {
            throw new runtime.RequiredError('updateCategoryEntity','Required parameter requestParameters.updateCategoryEntity was null or undefined when calling updateCategories.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/categories`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateCategoryEntity.map(UpdateCategoryEntityToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CategoryEntityFromJSON));
    }

    /**
     * User must have the PORTAL_CATEGORY[UPDATE] permission to use this service
     * Update an existing category
     */
    async updateCategories(requestParameters: UpdateCategoriesRequest): Promise<Array<CategoryEntity>> {
        const response = await this.updateCategoriesRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_CATEGORY[UPDATE] permission to use this service
     * Update the category
     */
    async updateCategoryRaw(requestParameters: UpdateCategoryRequest): Promise<runtime.ApiResponse<CategoryEntity>> {
        if (requestParameters.categoryId === null || requestParameters.categoryId === undefined) {
            throw new runtime.RequiredError('categoryId','Required parameter requestParameters.categoryId was null or undefined when calling updateCategory.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateCategory.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateCategory.');
        }

        if (requestParameters.updateCategoryEntity === null || requestParameters.updateCategoryEntity === undefined) {
            throw new runtime.RequiredError('updateCategoryEntity','Required parameter requestParameters.updateCategoryEntity was null or undefined when calling updateCategory.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/categories/{categoryId}`.replace(`{${"categoryId"}}`, encodeURIComponent(String(requestParameters.categoryId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCategoryEntityToJSON(requestParameters.updateCategoryEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CategoryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the PORTAL_CATEGORY[UPDATE] permission to use this service
     * Update the category
     */
    async updateCategory(requestParameters: UpdateCategoryRequest): Promise<CategoryEntity> {
        const response = await this.updateCategoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_CLIENT_REGISTRATION_PROVIDER[UPDATE] permission to use this service
     * Update a client registration provider
     */
    async updateClientRegistrationProviderRaw(requestParameters: UpdateClientRegistrationProviderRequest): Promise<runtime.ApiResponse<ClientRegistrationProviderEntity>> {
        if (requestParameters.clientRegistrationProvider === null || requestParameters.clientRegistrationProvider === undefined) {
            throw new runtime.RequiredError('clientRegistrationProvider','Required parameter requestParameters.clientRegistrationProvider was null or undefined when calling updateClientRegistrationProvider.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateClientRegistrationProvider.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateClientRegistrationProvider.');
        }

        if (requestParameters.updateClientRegistrationProviderEntity === null || requestParameters.updateClientRegistrationProviderEntity === undefined) {
            throw new runtime.RequiredError('updateClientRegistrationProviderEntity','Required parameter requestParameters.updateClientRegistrationProviderEntity was null or undefined when calling updateClientRegistrationProvider.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/applications/registration/providers/{clientRegistrationProvider}`.replace(`{${"clientRegistrationProvider"}}`, encodeURIComponent(String(requestParameters.clientRegistrationProvider))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateClientRegistrationProviderEntityToJSON(requestParameters.updateClientRegistrationProviderEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ClientRegistrationProviderEntityFromJSON(jsonValue));
    }

    /**
     * User must have the PORTAL_CLIENT_REGISTRATION_PROVIDER[UPDATE] permission to use this service
     * Update a client registration provider
     */
    async updateClientRegistrationProvider(requestParameters: UpdateClientRegistrationProviderRequest): Promise<ClientRegistrationProviderEntity> {
        const response = await this.updateClientRegistrationProviderRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the CUSTOM_USER_FIELDS[UPDATE] permission to use this service
     * Update a Custom User Field
     */
    async updateCustomUserFieldRaw(requestParameters: UpdateCustomUserFieldRequest): Promise<runtime.ApiResponse<CustomUserFieldEntity>> {
        if (requestParameters.key === null || requestParameters.key === undefined) {
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling updateCustomUserField.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateCustomUserField.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/custom-user-fields/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters.key))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CustomUserFieldEntityToJSON(requestParameters.customUserFieldEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomUserFieldEntityFromJSON(jsonValue));
    }

    /**
     * User must have the CUSTOM_USER_FIELDS[UPDATE] permission to use this service
     * Update a Custom User Field
     */
    async updateCustomUserField(requestParameters: UpdateCustomUserFieldRequest): Promise<CustomUserFieldEntity> {
        const response = await this.updateCustomUserFieldRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_DASHBOARD[UPDATE] permission to use this service
     * Update a platform dashboard
     */
    async updateDashboardRaw(requestParameters: UpdateDashboardRequest): Promise<runtime.ApiResponse<DashboardEntity>> {
        if (requestParameters.dashboardId === null || requestParameters.dashboardId === undefined) {
            throw new runtime.RequiredError('dashboardId','Required parameter requestParameters.dashboardId was null or undefined when calling updateDashboard.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateDashboard.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateDashboard.');
        }

        if (requestParameters.updateDashboardEntity === null || requestParameters.updateDashboardEntity === undefined) {
            throw new runtime.RequiredError('updateDashboardEntity','Required parameter requestParameters.updateDashboardEntity was null or undefined when calling updateDashboard.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dashboards/{dashboardId}`.replace(`{${"dashboardId"}}`, encodeURIComponent(String(requestParameters.dashboardId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateDashboardEntityToJSON(requestParameters.updateDashboardEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DashboardEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_DASHBOARD[UPDATE] permission to use this service
     * Update a platform dashboard
     */
    async updateDashboard(requestParameters: UpdateDashboardRequest): Promise<DashboardEntity> {
        const response = await this.updateDashboardRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the DICTIONARY[UPDATE] permission to use this service
     * Update a dictionary
     */
    async updateDictionaryRaw(requestParameters: UpdateDictionaryRequest): Promise<runtime.ApiResponse<DictionaryEntity>> {
        if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
            throw new runtime.RequiredError('dictionary','Required parameter requestParameters.dictionary was null or undefined when calling updateDictionary.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateDictionary.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateDictionary.');
        }

        if (requestParameters.updateDictionaryEntity === null || requestParameters.updateDictionaryEntity === undefined) {
            throw new runtime.RequiredError('updateDictionaryEntity','Required parameter requestParameters.updateDictionaryEntity was null or undefined when calling updateDictionary.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries/{dictionary}`.replace(`{${"dictionary"}}`, encodeURIComponent(String(requestParameters.dictionary))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateDictionaryEntityToJSON(requestParameters.updateDictionaryEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DictionaryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the DICTIONARY[UPDATE] permission to use this service
     * Update a dictionary
     */
    async updateDictionary(requestParameters: UpdateDictionaryRequest): Promise<DictionaryEntity> {
        const response = await this.updateDictionaryRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[UPDATE] permission to use this service
     * Update a platform entrypoint
     */
    async updateEntrypointRaw(requestParameters: UpdateEntrypointRequest): Promise<runtime.ApiResponse<EntrypointEntity>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateEntrypoint.');
        }

        if (requestParameters.updateEntryPointEntity === null || requestParameters.updateEntryPointEntity === undefined) {
            throw new runtime.RequiredError('updateEntryPointEntity','Required parameter requestParameters.updateEntryPointEntity was null or undefined when calling updateEntrypoint.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/entrypoints`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateEntryPointEntityToJSON(requestParameters.updateEntryPointEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EntrypointEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[UPDATE] permission to use this service
     * Update a platform entrypoint
     */
    async updateEntrypoint(requestParameters: UpdateEntrypointRequest): Promise<EntrypointEntity> {
        const response = await this.updateEntrypointRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[UPDATE] permission to use this service
     * Update a platform entrypoint
     */
    async updateEntrypoint1Raw(requestParameters: UpdateEntrypoint1Request): Promise<runtime.ApiResponse<EntrypointEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateEntrypoint1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateEntrypoint1.');
        }

        if (requestParameters.updateEntryPointEntity === null || requestParameters.updateEntryPointEntity === undefined) {
            throw new runtime.RequiredError('updateEntryPointEntity','Required parameter requestParameters.updateEntryPointEntity was null or undefined when calling updateEntrypoint1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/entrypoints`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateEntryPointEntityToJSON(requestParameters.updateEntryPointEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EntrypointEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ENTRYPOINT[UPDATE] permission to use this service
     * Update a platform entrypoint
     */
    async updateEntrypoint1(requestParameters: UpdateEntrypoint1Request): Promise<EntrypointEntity> {
        const response = await this.updateEntrypoint1Raw(requestParameters);
        return await response.value();
    }

    /**
     * Update generic notification settings
     */
    async updateGenericNotificationSettingsRaw(requestParameters: UpdateGenericNotificationSettingsRequest): Promise<runtime.ApiResponse<GenericNotificationConfigEntity>> {
        if (requestParameters.notificationId === null || requestParameters.notificationId === undefined) {
            throw new runtime.RequiredError('notificationId','Required parameter requestParameters.notificationId was null or undefined when calling updateGenericNotificationSettings.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateGenericNotificationSettings.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateGenericNotificationSettings.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/notificationsettings/{notificationId}`.replace(`{${"notificationId"}}`, encodeURIComponent(String(requestParameters.notificationId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: GenericNotificationConfigEntityToJSON(requestParameters.genericNotificationConfigEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GenericNotificationConfigEntityFromJSON(jsonValue));
    }

    /**
     * Update generic notification settings
     */
    async updateGenericNotificationSettings(requestParameters: UpdateGenericNotificationSettingsRequest): Promise<GenericNotificationConfigEntity> {
        const response = await this.updateGenericNotificationSettingsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an existing group
     */
    async updateGroupRaw(requestParameters: UpdateGroupRequest): Promise<runtime.ApiResponse<GroupEntity>> {
        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling updateGroup.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateGroup.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateGroup.');
        }

        if (requestParameters.updateGroupEntity === null || requestParameters.updateGroupEntity === undefined) {
            throw new runtime.RequiredError('updateGroupEntity','Required parameter requestParameters.updateGroupEntity was null or undefined when calling updateGroup.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups/{group}`.replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateGroupEntityToJSON(requestParameters.updateGroupEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupEntityFromJSON(jsonValue));
    }

    /**
     * Update an existing group
     */
    async updateGroup(requestParameters: UpdateGroupRequest): Promise<GroupEntity> {
        const response = await this.updateGroupRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the GROUP_INVITATION[UPDATE] permission to use this service
     * Update an invitation to join a group
     */
    async updateGroupInvitationRaw(requestParameters: UpdateGroupInvitationRequest): Promise<runtime.ApiResponse<InvitationEntity>> {
        if (requestParameters.invitation === null || requestParameters.invitation === undefined) {
            throw new runtime.RequiredError('invitation','Required parameter requestParameters.invitation was null or undefined when calling updateGroupInvitation.');
        }

        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling updateGroupInvitation.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateGroupInvitation.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateGroupInvitation.');
        }

        if (requestParameters.updateInvitationEntity === null || requestParameters.updateInvitationEntity === undefined) {
            throw new runtime.RequiredError('updateInvitationEntity','Required parameter requestParameters.updateInvitationEntity was null or undefined when calling updateGroupInvitation.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/groups/{group}/invitations/{invitation}`.replace(`{${"invitation"}}`, encodeURIComponent(String(requestParameters.invitation))).replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateInvitationEntityToJSON(requestParameters.updateInvitationEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InvitationEntityFromJSON(jsonValue));
    }

    /**
     * User must have the GROUP_INVITATION[UPDATE] permission to use this service
     * Update an invitation to join a group
     */
    async updateGroupInvitation(requestParameters: UpdateGroupInvitationRequest): Promise<InvitationEntity> {
        const response = await this.updateGroupInvitationRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[UPDATE] permission to use this service
     * Update an identity provider
     */
    async updateIdentityProviderRaw(requestParameters: UpdateIdentityProviderRequest): Promise<runtime.ApiResponse<IdentityProviderEntity>> {
        if (requestParameters.identityProvider === null || requestParameters.identityProvider === undefined) {
            throw new runtime.RequiredError('identityProvider','Required parameter requestParameters.identityProvider was null or undefined when calling updateIdentityProvider.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateIdentityProvider.');
        }

        if (requestParameters.updateIdentityProviderEntity === null || requestParameters.updateIdentityProviderEntity === undefined) {
            throw new runtime.RequiredError('updateIdentityProviderEntity','Required parameter requestParameters.updateIdentityProviderEntity was null or undefined when calling updateIdentityProvider.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/identities/{identityProvider}`.replace(`{${"identityProvider"}}`, encodeURIComponent(String(requestParameters.identityProvider))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateIdentityProviderEntityToJSON(requestParameters.updateIdentityProviderEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdentityProviderEntityFromJSON(jsonValue));
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[UPDATE] permission to use this service
     * Update an identity provider
     */
    async updateIdentityProvider(requestParameters: UpdateIdentityProviderRequest): Promise<IdentityProviderEntity> {
        const response = await this.updateIdentityProviderRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[UPDATE] permission to use this service
     * Update an identity provider
     */
    async updateIdentityProvider1Raw(requestParameters: UpdateIdentityProvider1Request): Promise<runtime.ApiResponse<IdentityProviderEntity>> {
        if (requestParameters.identityProvider === null || requestParameters.identityProvider === undefined) {
            throw new runtime.RequiredError('identityProvider','Required parameter requestParameters.identityProvider was null or undefined when calling updateIdentityProvider1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateIdentityProvider1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateIdentityProvider1.');
        }

        if (requestParameters.updateIdentityProviderEntity === null || requestParameters.updateIdentityProviderEntity === undefined) {
            throw new runtime.RequiredError('updateIdentityProviderEntity','Required parameter requestParameters.updateIdentityProviderEntity was null or undefined when calling updateIdentityProvider1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/identities/{identityProvider}`.replace(`{${"identityProvider"}}`, encodeURIComponent(String(requestParameters.identityProvider))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateIdentityProviderEntityToJSON(requestParameters.updateIdentityProviderEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdentityProviderEntityFromJSON(jsonValue));
    }

    /**
     * User must have the ORGANIZATION_IDENTITY_PROVIDER[UPDATE] permission to use this service
     * Update an identity provider
     */
    async updateIdentityProvider1(requestParameters: UpdateIdentityProvider1Request): Promise<IdentityProviderEntity> {
        const response = await this.updateIdentityProvider1Raw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_METADATA[UPDATE] permission to use this service
     * Update a platform metadata
     */
    async updateMetadataRaw(requestParameters: UpdateMetadataRequest): Promise<runtime.ApiResponse<MetadataEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateMetadata.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateMetadata.');
        }

        if (requestParameters.updateMetadataEntity === null || requestParameters.updateMetadataEntity === undefined) {
            throw new runtime.RequiredError('updateMetadataEntity','Required parameter requestParameters.updateMetadataEntity was null or undefined when calling updateMetadata.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/metadata`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMetadataEntityToJSON(requestParameters.updateMetadataEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MetadataEntityFromJSON(jsonValue));
    }

    /**
     * User must have the PORTAL_METADATA[UPDATE] permission to use this service
     * Update a platform metadata
     */
    async updateMetadata(requestParameters: UpdateMetadataRequest): Promise<MetadataEntity> {
        const response = await this.updateMetadataRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the NOTIFICATION_TEMPLATES[UPDATE] permission to use this service
     * Update an existing notification template
     */
    async updateNotificationTemplateRaw(requestParameters: UpdateNotificationTemplateRequest): Promise<runtime.ApiResponse<NotificationTemplateEntity>> {
        if (requestParameters.notificationTemplateId === null || requestParameters.notificationTemplateId === undefined) {
            throw new runtime.RequiredError('notificationTemplateId','Required parameter requestParameters.notificationTemplateId was null or undefined when calling updateNotificationTemplate.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateNotificationTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/notification-templates/{notificationTemplateId}`.replace(`{${"notificationTemplateId"}}`, encodeURIComponent(String(requestParameters.notificationTemplateId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: NotificationTemplateEntityToJSON(requestParameters.notificationTemplateEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => NotificationTemplateEntityFromJSON(jsonValue));
    }

    /**
     * User must have the NOTIFICATION_TEMPLATES[UPDATE] permission to use this service
     * Update an existing notification template
     */
    async updateNotificationTemplate(requestParameters: UpdateNotificationTemplateRequest): Promise<NotificationTemplateEntity> {
        const response = await this.updateNotificationTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update portal notification settings
     */
    async updatePortalNotificationSettingsRaw(requestParameters: UpdatePortalNotificationSettingsRequest): Promise<runtime.ApiResponse<PortalNotificationConfigEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updatePortalNotificationSettings.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updatePortalNotificationSettings.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/notificationsettings`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PortalNotificationConfigEntityToJSON(requestParameters.portalNotificationConfigEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PortalNotificationConfigEntityFromJSON(jsonValue));
    }

    /**
     * Update portal notification settings
     */
    async updatePortalNotificationSettings(requestParameters: UpdatePortalNotificationSettingsRequest): Promise<PortalNotificationConfigEntity> {
        const response = await this.updatePortalNotificationSettingsRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_QUALITY_RULE[READ] permission to use this service
     * Update a quality rule
     */
    async updateQualityRuleRaw(requestParameters: UpdateQualityRuleRequest): Promise<runtime.ApiResponse<QualityRuleEntity>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateQualityRule.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateQualityRule.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateQualityRule.');
        }

        if (requestParameters.updateQualityRuleEntity === null || requestParameters.updateQualityRuleEntity === undefined) {
            throw new runtime.RequiredError('updateQualityRuleEntity','Required parameter requestParameters.updateQualityRuleEntity was null or undefined when calling updateQualityRule.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/quality-rules/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateQualityRuleEntityToJSON(requestParameters.updateQualityRuleEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => QualityRuleEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_QUALITY_RULE[READ] permission to use this service
     * Update a quality rule
     */
    async updateQualityRule(requestParameters: UpdateQualityRuleRequest): Promise<QualityRuleEntity> {
        const response = await this.updateQualityRuleRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ROLE[UPDATE] permission to use this service
     * Update a role
     */
    async updateRoleRaw(requestParameters: UpdateRoleRequest): Promise<runtime.ApiResponse<RoleEntity>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling updateRole.');
        }

        if (requestParameters.role === null || requestParameters.role === undefined) {
            throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling updateRole.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateRole.');
        }

        if (requestParameters.updateRoleEntity === null || requestParameters.updateRoleEntity === undefined) {
            throw new runtime.RequiredError('updateRoleEntity','Required parameter requestParameters.updateRoleEntity was null or undefined when calling updateRole.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/rolescopes/{scope}/roles/{role}`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"role"}}`, encodeURIComponent(String(requestParameters.role))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateRoleEntityToJSON(requestParameters.updateRoleEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ROLE[UPDATE] permission to use this service
     * Update a role
     */
    async updateRole(requestParameters: UpdateRoleRequest): Promise<RoleEntity> {
        const response = await this.updateRoleRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ROLE[UPDATE] permission to use this service
     * Update a role
     */
    async updateRole1Raw(requestParameters: UpdateRole1Request): Promise<runtime.ApiResponse<RoleEntity>> {
        if (requestParameters.scope === null || requestParameters.scope === undefined) {
            throw new runtime.RequiredError('scope','Required parameter requestParameters.scope was null or undefined when calling updateRole1.');
        }

        if (requestParameters.role === null || requestParameters.role === undefined) {
            throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling updateRole1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateRole1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateRole1.');
        }

        if (requestParameters.updateRoleEntity === null || requestParameters.updateRoleEntity === undefined) {
            throw new runtime.RequiredError('updateRoleEntity','Required parameter requestParameters.updateRoleEntity was null or undefined when calling updateRole1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/rolescopes/{scope}/roles/{role}`.replace(`{${"scope"}}`, encodeURIComponent(String(requestParameters.scope))).replace(`{${"role"}}`, encodeURIComponent(String(requestParameters.role))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateRoleEntityToJSON(requestParameters.updateRoleEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ROLE[UPDATE] permission to use this service
     * Update a role
     */
    async updateRole1(requestParameters: UpdateRole1Request): Promise<RoleEntity> {
        const response = await this.updateRole1Raw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_TAG[UPDATE] permission to use this service
     * Update an existing sharding tag
     */
    async updateTagRaw(requestParameters: UpdateTagRequest): Promise<runtime.ApiResponse<TagEntity>> {
        if (requestParameters.tag === null || requestParameters.tag === undefined) {
            throw new runtime.RequiredError('tag','Required parameter requestParameters.tag was null or undefined when calling updateTag.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateTag.');
        }

        if (requestParameters.updateTagEntity === null || requestParameters.updateTagEntity === undefined) {
            throw new runtime.RequiredError('updateTagEntity','Required parameter requestParameters.updateTagEntity was null or undefined when calling updateTag.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/tags/{tag}`.replace(`{${"tag"}}`, encodeURIComponent(String(requestParameters.tag))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateTagEntityToJSON(requestParameters.updateTagEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TagEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_TAG[UPDATE] permission to use this service
     * Update an existing sharding tag
     */
    async updateTag(requestParameters: UpdateTagRequest): Promise<TagEntity> {
        const response = await this.updateTagRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_TAG[UPDATE] permission to use this service
     * Update an existing sharding tag
     */
    async updateTag1Raw(requestParameters: UpdateTag1Request): Promise<runtime.ApiResponse<TagEntity>> {
        if (requestParameters.tag === null || requestParameters.tag === undefined) {
            throw new runtime.RequiredError('tag','Required parameter requestParameters.tag was null or undefined when calling updateTag1.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateTag1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateTag1.');
        }

        if (requestParameters.updateTagEntity === null || requestParameters.updateTagEntity === undefined) {
            throw new runtime.RequiredError('updateTagEntity','Required parameter requestParameters.updateTagEntity was null or undefined when calling updateTag1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/tags/{tag}`.replace(`{${"tag"}}`, encodeURIComponent(String(requestParameters.tag))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateTagEntityToJSON(requestParameters.updateTagEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TagEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_TAG[UPDATE] permission to use this service
     * Update an existing sharding tag
     */
    async updateTag1(requestParameters: UpdateTag1Request): Promise<TagEntity> {
        const response = await this.updateTag1Raw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_TENANT[UPDATE] permission to use this service
     * Update a tenant
     */
    async updateTenantsRaw(requestParameters: UpdateTenantsRequest): Promise<runtime.ApiResponse<Array<TenantEntity>>> {
        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateTenants.');
        }

        if (requestParameters.updateTenantEntity === null || requestParameters.updateTenantEntity === undefined) {
            throw new runtime.RequiredError('updateTenantEntity','Required parameter requestParameters.updateTenantEntity was null or undefined when calling updateTenants.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/configuration/tenants`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateTenantEntity.map(UpdateTenantEntityToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TenantEntityFromJSON));
    }

    /**
     * User must have the MANAGEMENT_TENANT[UPDATE] permission to use this service
     * Update a tenant
     */
    async updateTenants(requestParameters: UpdateTenantsRequest): Promise<Array<TenantEntity>> {
        const response = await this.updateTenantsRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_TENANT[UPDATE] permission to use this service
     * Update a tenant
     */
    async updateTenants1Raw(requestParameters: UpdateTenants1Request): Promise<runtime.ApiResponse<Array<TenantEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateTenants1.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateTenants1.');
        }

        if (requestParameters.updateTenantEntity === null || requestParameters.updateTenantEntity === undefined) {
            throw new runtime.RequiredError('updateTenantEntity','Required parameter requestParameters.updateTenantEntity was null or undefined when calling updateTenants1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/tenants`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateTenantEntity.map(UpdateTenantEntityToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TenantEntityFromJSON));
    }

    /**
     * User must have the MANAGEMENT_TENANT[UPDATE] permission to use this service
     * Update a tenant
     */
    async updateTenants1(requestParameters: UpdateTenants1Request): Promise<Array<TenantEntity>> {
        const response = await this.updateTenants1Raw(requestParameters);
        return await response.value();
    }

    /**
     */
    async updateThemeRaw(requestParameters: UpdateThemeRequest): Promise<runtime.ApiResponse<ThemeEntity>> {
        if (requestParameters.themeId === null || requestParameters.themeId === undefined) {
            throw new runtime.RequiredError('themeId','Required parameter requestParameters.themeId was null or undefined when calling updateTheme.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateTheme.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateTheme.');
        }

        if (requestParameters.updateThemeEntity === null || requestParameters.updateThemeEntity === undefined) {
            throw new runtime.RequiredError('updateThemeEntity','Required parameter requestParameters.updateThemeEntity was null or undefined when calling updateTheme.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/themes/{themeId}`.replace(`{${"themeId"}}`, encodeURIComponent(String(requestParameters.themeId))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateThemeEntityToJSON(requestParameters.updateThemeEntity),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ThemeEntityFromJSON(jsonValue));
    }

    /**
     */
    async updateTheme(requestParameters: UpdateThemeRequest): Promise<ThemeEntity> {
        const response = await this.updateThemeRaw(requestParameters);
        return await response.value();
    }

    /**
     * User must have the PORTAL_TOP_APIS[UPDATE] permission to use this service
     * Update a top API
     */
    async updateTopApiRaw(requestParameters: UpdateTopApiRequest): Promise<runtime.ApiResponse<Array<TopApiEntity>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateTopApi.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateTopApi.');
        }

        if (requestParameters.updateTopApiEntity === null || requestParameters.updateTopApiEntity === undefined) {
            throw new runtime.RequiredError('updateTopApiEntity','Required parameter requestParameters.updateTopApiEntity was null or undefined when calling updateTopApi.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/top-apis`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateTopApiEntity.map(UpdateTopApiEntityToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TopApiEntityFromJSON));
    }

    /**
     * User must have the PORTAL_TOP_APIS[UPDATE] permission to use this service
     * Update a top API
     */
    async updateTopApi(requestParameters: UpdateTopApiRequest): Promise<Array<TopApiEntity>> {
        const response = await this.updateTopApiRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetDashboardsReferenceTypeEnum {
    PLATFORM = 'PLATFORM',
    API = 'API',
    APPLICATION = 'APPLICATION',
    HOME = 'HOME'
}
