/* tslint:disable */
/* eslint-disable */
/**
 * Gravitee.io Portal Rest API
 * API dedicated to the devportal part of Gravitee
 *
 * Contact: contact@graviteesource.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    Key,
    KeyFromJSON,
    KeyToJSON,
    Subscription,
    SubscriptionFromJSON,
    SubscriptionToJSON,
    SubscriptionInput,
    SubscriptionInputFromJSON,
    SubscriptionInputToJSON,
    SubscriptionsResponse,
    SubscriptionsResponseFromJSON,
    SubscriptionsResponseToJSON,
} from '../models';

export interface CloseSubscriptionRequest {
    subscriptionId: string;
}

export interface CreateSubscriptionRequest {
    subscriptionInput?: SubscriptionInput;
}

export interface GetSubscriptionByIdRequest {
    subscriptionId: string;
    include?: Array<GetSubscriptionByIdIncludeEnum>;
}

export interface GetSubscriptionsRequest {
    apiId?: string;
    applicationId?: string;
    statuses?: Array<GetSubscriptionsStatusesEnum>;
    page?: number;
    size?: number;
}

export interface RenewKeySubscriptionRequest {
    subscriptionId: string;
    requestBody?: Array<string>;
}

export interface RevokeKeySubscriptionRequest {
    subscriptionId: string;
    apiKey: string;
}

/**
 * 
 */
export class SubscriptionApi extends runtime.BaseAPI {

    /**
     * Close a subscription.  User must have APPLICATION_SUBSCRIPTION[DELETE] permission. 
     * Close a subscription
     */
    async closeSubscriptionRaw(requestParameters: CloseSubscriptionRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.subscriptionId === null || requestParameters.subscriptionId === undefined) {
            throw new runtime.RequiredError('subscriptionId','Required parameter requestParameters.subscriptionId was null or undefined when calling closeSubscription.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/subscriptions/{subscriptionId}/_close`.replace(`{${"subscriptionId"}}`, encodeURIComponent(String(requestParameters.subscriptionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Close a subscription.  User must have APPLICATION_SUBSCRIPTION[DELETE] permission. 
     * Close a subscription
     */
    async closeSubscription(requestParameters: CloseSubscriptionRequest): Promise<void> {
        await this.closeSubscriptionRaw(requestParameters);
    }

    /**
     * Create a new subscription.  User must have APPLICATION_SUBSCRIPTION[CREATE] permission. 
     * Create a subscription.
     */
    async createSubscriptionRaw(requestParameters: CreateSubscriptionRequest): Promise<runtime.ApiResponse<Subscription>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/subscriptions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SubscriptionInputToJSON(requestParameters.subscriptionInput),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * Create a new subscription.  User must have APPLICATION_SUBSCRIPTION[CREATE] permission. 
     * Create a subscription.
     */
    async createSubscription(requestParameters: CreateSubscriptionRequest): Promise<Subscription> {
        const response = await this.createSubscriptionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a subscription.  User must have API_SUBSCRIPTION[CREATE] or APPLICATION_SUBSCRIPTION[CREATE] permission. 
     * Get a subscription.
     */
    async getSubscriptionByIdRaw(requestParameters: GetSubscriptionByIdRequest): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.subscriptionId === null || requestParameters.subscriptionId === undefined) {
            throw new runtime.RequiredError('subscriptionId','Required parameter requestParameters.subscriptionId was null or undefined when calling getSubscriptionById.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.include) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/subscriptions/{subscriptionId}`.replace(`{${"subscriptionId"}}`, encodeURIComponent(String(requestParameters.subscriptionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * Get a subscription.  User must have API_SUBSCRIPTION[CREATE] or APPLICATION_SUBSCRIPTION[CREATE] permission. 
     * Get a subscription.
     */
    async getSubscriptionById(requestParameters: GetSubscriptionByIdRequest): Promise<Subscription> {
        const response = await this.getSubscriptionByIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * List all ACCEPTED, PAUSED & PENDING subscriptions, filtered by api and/or by application. At least an api or an application must be provided.  User must have the APPLICATION_SUBSCRIPTION[READ] permission to list subscription with application query param.\\ User must have the API_SUBSCRIPTION[READ] permission to list subscription with api query param. 
     */
    async getSubscriptionsRaw(requestParameters: GetSubscriptionsRequest): Promise<runtime.ApiResponse<SubscriptionsResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.apiId !== undefined) {
            queryParameters['apiId'] = requestParameters.apiId;
        }

        if (requestParameters.applicationId !== undefined) {
            queryParameters['applicationId'] = requestParameters.applicationId;
        }

        if (requestParameters.statuses) {
            queryParameters['statuses'] = requestParameters.statuses;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/subscriptions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionsResponseFromJSON(jsonValue));
    }

    /**
     * List all ACCEPTED, PAUSED & PENDING subscriptions, filtered by api and/or by application. At least an api or an application must be provided.  User must have the APPLICATION_SUBSCRIPTION[READ] permission to list subscription with application query param.\\ User must have the API_SUBSCRIPTION[READ] permission to list subscription with api query param. 
     */
    async getSubscriptions(requestParameters: GetSubscriptionsRequest): Promise<SubscriptionsResponse> {
        const response = await this.getSubscriptionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Renew a key subscription.  User must have API_SUBSCRIPTION[UPDATE] or APPLICATION_SUBSCRIPTION[UPDATE] permission. 
     * Renew a key subscription.
     */
    async renewKeySubscriptionRaw(requestParameters: RenewKeySubscriptionRequest): Promise<runtime.ApiResponse<Key>> {
        if (requestParameters.subscriptionId === null || requestParameters.subscriptionId === undefined) {
            throw new runtime.RequiredError('subscriptionId','Required parameter requestParameters.subscriptionId was null or undefined when calling renewKeySubscription.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/subscriptions/{subscriptionId}/keys/_renew`.replace(`{${"subscriptionId"}}`, encodeURIComponent(String(requestParameters.subscriptionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => KeyFromJSON(jsonValue));
    }

    /**
     * Renew a key subscription.  User must have API_SUBSCRIPTION[UPDATE] or APPLICATION_SUBSCRIPTION[UPDATE] permission. 
     * Renew a key subscription.
     */
    async renewKeySubscription(requestParameters: RenewKeySubscriptionRequest): Promise<Key> {
        const response = await this.renewKeySubscriptionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Revoke a key subscription.  User must have API_SUBSCRIPTION[UPDATE] or APPLICATION_SUBSCRIPTION[UPDATE] permission. 
     * Revoke a key subscription.
     */
    async revokeKeySubscriptionRaw(requestParameters: RevokeKeySubscriptionRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.subscriptionId === null || requestParameters.subscriptionId === undefined) {
            throw new runtime.RequiredError('subscriptionId','Required parameter requestParameters.subscriptionId was null or undefined when calling revokeKeySubscription.');
        }

        if (requestParameters.apiKey === null || requestParameters.apiKey === undefined) {
            throw new runtime.RequiredError('apiKey','Required parameter requestParameters.apiKey was null or undefined when calling revokeKeySubscription.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/subscriptions/{subscriptionId}/keys/{apiKey}/_revoke`.replace(`{${"subscriptionId"}}`, encodeURIComponent(String(requestParameters.subscriptionId))).replace(`{${"apiKey"}}`, encodeURIComponent(String(requestParameters.apiKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revoke a key subscription.  User must have API_SUBSCRIPTION[UPDATE] or APPLICATION_SUBSCRIPTION[UPDATE] permission. 
     * Revoke a key subscription.
     */
    async revokeKeySubscription(requestParameters: RevokeKeySubscriptionRequest): Promise<void> {
        await this.revokeKeySubscriptionRaw(requestParameters);
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetSubscriptionByIdIncludeEnum {
    Keys = 'keys'
}
/**
    * @export
    * @enum {string}
    */
export enum GetSubscriptionsStatusesEnum {
    ACCEPTED = 'ACCEPTED',
    CLOSED = 'CLOSED',
    PAUSED = 'PAUSED',
    PENDING = 'PENDING',
    REJECTED = 'REJECTED'
}
