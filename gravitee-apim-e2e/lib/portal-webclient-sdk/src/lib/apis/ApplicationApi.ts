/* tslint:disable */
/* eslint-disable */
/**
 * Gravitee.io Portal Rest API
 * API dedicated to the devportal part of Gravitee
 *
 * Contact: contact@graviteesource.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Alert,
    AlertFromJSON,
    AlertToJSON,
    AlertInput,
    AlertInputFromJSON,
    AlertInputToJSON,
    AlertStatusResponse,
    AlertStatusResponseFromJSON,
    AlertStatusResponseToJSON,
    ApisResponse,
    ApisResponseFromJSON,
    ApisResponseToJSON,
    Application,
    ApplicationFromJSON,
    ApplicationToJSON,
    ApplicationInput,
    ApplicationInputFromJSON,
    ApplicationInputToJSON,
    ApplicationType,
    ApplicationTypeFromJSON,
    ApplicationTypeToJSON,
    ApplicationsResponse,
    ApplicationsResponseFromJSON,
    ApplicationsResponseToJSON,
    CountAnalytics, DateHistoAnalytics, GroupByAnalytics,
    GroupByAnalyticsFromJSON, CountAnalyticsFromJSON,
    GroupByAnalyticsToJSON,
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    Hook,
    HookFromJSON,
    HookToJSON,
    Key,
    KeyFromJSON,
    KeyToJSON,
    Log,
    LogFromJSON,
    LogToJSON,
    LogsResponse,
    LogsResponseFromJSON,
    LogsResponseToJSON,
    Member,
    MemberFromJSON,
    MemberToJSON,
    MemberInput,
    MemberInputFromJSON,
    MemberInputToJSON,
    MembersResponse,
    MembersResponseFromJSON,
    MembersResponseToJSON,
    NotificationInput,
    NotificationInputFromJSON,
    NotificationInputToJSON,
    ReferenceMetadata,
    ReferenceMetadataFromJSON,
    ReferenceMetadataToJSON,
    ReferenceMetadataInput,
    ReferenceMetadataInputFromJSON,
    ReferenceMetadataInputToJSON,
    ReferenceMetadataResponse,
    ReferenceMetadataResponseFromJSON,
    ReferenceMetadataResponseToJSON,
    TransferOwnershipInput,
    TransferOwnershipInputFromJSON,
    TransferOwnershipInputToJSON,
} from '../models';

export interface CreateApplicationRequest {
    applicationInput?: ApplicationInput;
}

export interface CreateApplicationAlertRequest {
    applicationId: string;
    alertInput?: AlertInput;
}

export interface CreateApplicationMemberRequest {
    applicationId: string;
    memberInput?: MemberInput;
}

export interface CreateApplicationMetadataRequest {
    applicationId: string;
    referenceMetadataInput?: ReferenceMetadataInput;
}

export interface DeleteApplicationAlertRequest {
    applicationId: string;
    alertId: string;
}

export interface DeleteApplicationByApplicationIdRequest {
    applicationId: string;
}

export interface DeleteApplicationMemberRequest {
    applicationId: string;
    memberId: string;
}

export interface DeleteApplicationMetadataRequest {
    applicationId: string;
    metadataId: string;
}

export interface ExportApplicationLogsByApplicationIdRequest {
    applicationId: string;
    page?: number;
    size?: number;
    from?: number;
    to?: number;
    query?: string;
    field?: string;
    order?: ExportApplicationLogsByApplicationIdOrderEnum;
}

export interface GetAlertsByApplicationIdRequest {
    applicationId: string;
}

export interface GetApplicationAlertStatusRequest {
    applicationId: string;
}

export interface GetApplicationAnalyticsRequest {
    applicationId: string;
    page?: number;
    size?: number;
    from?: number;
    to?: number;
    interval?: number;
    query?: string;
    field?: string;
    type?: GetApplicationAnalyticsTypeEnum;
    ranges?: string;
    aggs?: string;
    order?: string;
}

export interface GetApplicationBackgroundByApplicationIdRequest {
    applicationId: string;
}

export interface GetApplicationByApplicationIdRequest {
    applicationId: string;
}

export interface GetApplicationLogByApplicationIdAndLogIdRequest {
    applicationId: string;
    logId: string;
    timestamp?: number;
}

export interface GetApplicationLogsRequest {
    applicationId: string;
    page?: number;
    size?: number;
    from?: number;
    to?: number;
    query?: string;
    field?: string;
    order?: GetApplicationLogsOrderEnum;
}

export interface GetApplicationMemberByApplicationIdAndMemberIdRequest {
    applicationId: string;
    memberId: string;
}

export interface GetApplicationMetadataByApplicationIdAndMetadataIdRequest {
    applicationId: string;
    metadataId: string;
}

export interface GetApplicationPictureByApplicationIdRequest {
    applicationId: string;
}

export interface GetApplicationTypeRequest {
    applicationId: string;
}

export interface GetApplicationsRequest {
    page?: number;
    size?: number;
    forSubscription?: boolean;
    order?: string;
}

export interface GetMembersByApplicationIdRequest {
    applicationId: string;
    page?: number;
    size?: number;
}

export interface GetMetadataByApplicationIdRequest {
    applicationId: string;
    page?: number;
    size?: number;
}

export interface GetNotificationsByApplicationIdRequest {
    applicationId: string;
}

export interface GetSubscriberApisByApplicationIdRequest {
    applicationId: string;
    page?: number;
    size?: number;
    statuses?: Array<GetSubscriberApisByApplicationIdStatusesEnum>;
}

export interface RenewApplicationSecretRequest {
    applicationId: string;
}

export interface RenewSharedKeyRequest {
    applicationId: string;
}

export interface RevokeSharedKeyRequest {
    applicationId: string;
    apiKey: string;
}

export interface TransferMemberOwnershipRequest {
    applicationId: string;
    transferOwnershipInput?: TransferOwnershipInput;
}

export interface UpdateAlertRequest {
    applicationId: string;
    alertId: string;
    alertInput?: AlertInput;
}

export interface UpdateApplicationByApplicationIdRequest {
    applicationId: string;
    application?: Application;
}

export interface UpdateApplicationMemberByApplicationIdAndMemberIdRequest {
    applicationId: string;
    memberId: string;
    memberInput?: MemberInput;
}

export interface UpdateApplicationMetadataByApplicationIdAndMetadataIdRequest {
    applicationId: string;
    metadataId: string;
    referenceMetadataInput?: ReferenceMetadataInput;
}

export interface UpdateApplicationNotificationsRequest {
    applicationId: string;
    notificationInput?: NotificationInput;
}

/**
 * 
 */
export class ApplicationApi extends runtime.BaseAPI {

    /**
     * Create an application.  User must have MANAGEMENT_APPLICATION[CREATE] permission. 
     * Create an application
     */
    async createApplicationRaw(requestParameters: CreateApplicationRequest): Promise<runtime.ApiResponse<Application>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ApplicationInputToJSON(requestParameters.applicationInput),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
    }

    /**
     * Create an application.  User must have MANAGEMENT_APPLICATION[CREATE] permission. 
     * Create an application
     */
    async createApplication(requestParameters: CreateApplicationRequest): Promise<Application> {
        const response = await this.createApplicationRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create an application alert.  User must have the APPLICATION_ALERT[CREATE] permission. 
     * Create an application alert
     */
    async createApplicationAlertRaw(requestParameters: CreateApplicationAlertRequest): Promise<runtime.ApiResponse<Alert>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling createApplicationAlert.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/alerts`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AlertInputToJSON(requestParameters.alertInput),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertFromJSON(jsonValue));
    }

    /**
     * Create an application alert.  User must have the APPLICATION_ALERT[CREATE] permission. 
     * Create an application alert
     */
    async createApplicationAlert(requestParameters: CreateApplicationAlertRequest): Promise<Alert> {
        const response = await this.createApplicationAlertRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create an application member.  User must have the APPLICATION_MEMBER[CREATE] permission. 
     * Create an application member
     */
    async createApplicationMemberRaw(requestParameters: CreateApplicationMemberRequest): Promise<runtime.ApiResponse<Member>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling createApplicationMember.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/members`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MemberInputToJSON(requestParameters.memberInput),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MemberFromJSON(jsonValue));
    }

    /**
     * Create an application member.  User must have the APPLICATION_MEMBER[CREATE] permission. 
     * Create an application member
     */
    async createApplicationMember(requestParameters: CreateApplicationMemberRequest): Promise<Member> {
        const response = await this.createApplicationMemberRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create an application metadata.  User must have the APPLICATION_METADATA[CREATE] permission. 
     * Create an application metadata
     */
    async createApplicationMetadataRaw(requestParameters: CreateApplicationMetadataRequest): Promise<runtime.ApiResponse<ReferenceMetadata>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling createApplicationMetadata.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/metadata`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReferenceMetadataInputToJSON(requestParameters.referenceMetadataInput),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ReferenceMetadataFromJSON(jsonValue));
    }

    /**
     * Create an application metadata.  User must have the APPLICATION_METADATA[CREATE] permission. 
     * Create an application metadata
     */
    async createApplicationMetadata(requestParameters: CreateApplicationMetadataRequest): Promise<ReferenceMetadata> {
        const response = await this.createApplicationMetadataRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete a alert for an Application.  The current user must have APPLICATION_ALERT[DELETE] permission to delete a alert. 
     * Delete a alert for an Application
     */
    async deleteApplicationAlertRaw(requestParameters: DeleteApplicationAlertRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling deleteApplicationAlert.');
        }

        if (requestParameters.alertId === null || requestParameters.alertId === undefined) {
            throw new runtime.RequiredError('alertId','Required parameter requestParameters.alertId was null or undefined when calling deleteApplicationAlert.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/alerts/{alertId}`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))).replace(`{${"alertId"}}`, encodeURIComponent(String(requestParameters.alertId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a alert for an Application.  The current user must have APPLICATION_ALERT[DELETE] permission to delete a alert. 
     * Delete a alert for an Application
     */
    async deleteApplicationAlert(requestParameters: DeleteApplicationAlertRequest): Promise<void> {
        await this.deleteApplicationAlertRaw(requestParameters);
    }

    /**
     * Delete an application.  User must have the APPLICATION_DEFINITION[DELETE] permission. 
     * Delete an application
     */
    async deleteApplicationByApplicationIdRaw(requestParameters: DeleteApplicationByApplicationIdRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling deleteApplicationByApplicationId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an application.  User must have the APPLICATION_DEFINITION[DELETE] permission. 
     * Delete an application
     */
    async deleteApplicationByApplicationId(requestParameters: DeleteApplicationByApplicationIdRequest): Promise<void> {
        await this.deleteApplicationByApplicationIdRaw(requestParameters);
    }

    /**
     * Remove an application member.  User must have the APPLICATION_MEMBER[DELETE] permission. 
     * Remove an application member
     */
    async deleteApplicationMemberRaw(requestParameters: DeleteApplicationMemberRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling deleteApplicationMember.');
        }

        if (requestParameters.memberId === null || requestParameters.memberId === undefined) {
            throw new runtime.RequiredError('memberId','Required parameter requestParameters.memberId was null or undefined when calling deleteApplicationMember.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/members/{memberId}`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))).replace(`{${"memberId"}}`, encodeURIComponent(String(requestParameters.memberId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove an application member.  User must have the APPLICATION_MEMBER[DELETE] permission. 
     * Remove an application member
     */
    async deleteApplicationMember(requestParameters: DeleteApplicationMemberRequest): Promise<void> {
        await this.deleteApplicationMemberRaw(requestParameters);
    }

    /**
     * Remove an application metadata.  User must have the APPLICATION_METADATA[DELETE] permission. 
     * Remove an application metadata
     */
    async deleteApplicationMetadataRaw(requestParameters: DeleteApplicationMetadataRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling deleteApplicationMetadata.');
        }

        if (requestParameters.metadataId === null || requestParameters.metadataId === undefined) {
            throw new runtime.RequiredError('metadataId','Required parameter requestParameters.metadataId was null or undefined when calling deleteApplicationMetadata.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/metadata/{metadataId}`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))).replace(`{${"metadataId"}}`, encodeURIComponent(String(requestParameters.metadataId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove an application metadata.  User must have the APPLICATION_METADATA[DELETE] permission. 
     * Remove an application metadata
     */
    async deleteApplicationMetadata(requestParameters: DeleteApplicationMetadataRequest): Promise<void> {
        await this.deleteApplicationMetadataRaw(requestParameters);
    }

    /**
     * Export application logs as CSV.  User must have the APPLICATION_LOG[READ] permission. 
     * Export application logs as CSV
     */
    async exportApplicationLogsByApplicationIdRaw(requestParameters: ExportApplicationLogsByApplicationIdRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling exportApplicationLogsByApplicationId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.to !== undefined) {
            queryParameters['to'] = requestParameters.to;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.field !== undefined) {
            queryParameters['field'] = requestParameters.field;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/logs/_export`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Export application logs as CSV.  User must have the APPLICATION_LOG[READ] permission. 
     * Export application logs as CSV
     */
    async exportApplicationLogsByApplicationId(requestParameters: ExportApplicationLogsByApplicationIdRequest): Promise<string> {
        const response = await this.exportApplicationLogsByApplicationIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get application alerts.  User must have APPLICATION_ALERT[READ] permission to get alerts. 
     * Get application alerts
     */
    async getAlertsByApplicationIdRaw(requestParameters: GetAlertsByApplicationIdRequest): Promise<runtime.ApiResponse<Array<Alert>>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getAlertsByApplicationId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/alerts`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AlertFromJSON));
    }

    /**
     * Get application alerts.  User must have APPLICATION_ALERT[READ] permission to get alerts. 
     * Get application alerts
     */
    async getAlertsByApplicationId(requestParameters: GetAlertsByApplicationIdRequest): Promise<Array<Alert>> {
        const response = await this.getAlertsByApplicationIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get application alert status.  User must have APPLICATION_ALERT[READ] permission to get alert status. 
     * Get application alert status
     */
    async getApplicationAlertStatusRaw(requestParameters: GetApplicationAlertStatusRequest): Promise<runtime.ApiResponse<AlertStatusResponse>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getApplicationAlertStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/alerts/status`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertStatusResponseFromJSON(jsonValue));
    }

    /**
     * Get application alert status.  User must have APPLICATION_ALERT[READ] permission to get alert status. 
     * Get application alert status
     */
    async getApplicationAlertStatus(requestParameters: GetApplicationAlertStatusRequest): Promise<AlertStatusResponse> {
        const response = await this.getApplicationAlertStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the application analytics.  User must have the APPLICATION_ANALYTICS[READ] permission. 
     * Get Application analytics
     */
    async getApplicationAnalyticsRaw(requestParameters: GetApplicationAnalyticsRequest): Promise<runtime.ApiResponse<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getApplicationAnalytics.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.to !== undefined) {
            queryParameters['to'] = requestParameters.to;
        }

        if (requestParameters.interval !== undefined) {
            queryParameters['interval'] = requestParameters.interval;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.field !== undefined) {
            queryParameters['field'] = requestParameters.field;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.ranges !== undefined) {
            queryParameters['ranges'] = requestParameters.ranges;
        }

        if (requestParameters.aggs !== undefined) {
            queryParameters['aggs'] = requestParameters.aggs;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/analytics`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CountAnalyticsFromJSON(jsonValue));
    }

    /**
     * Get the application analytics.  User must have the APPLICATION_ANALYTICS[READ] permission. 
     * Get Application analytics
     */
    async getApplicationAnalytics(requestParameters: GetApplicationAnalyticsRequest): Promise<DateHistoAnalytics | GroupByAnalytics | CountAnalytics> {
        const response = await this.getApplicationAnalyticsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the application\'s background.  User must have APPLICATION_DEFINITION[READ] permission. 
     * Get the application\'s background
     */
    async getApplicationBackgroundByApplicationIdRaw(requestParameters: GetApplicationBackgroundByApplicationIdRequest): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getApplicationBackgroundByApplicationId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/background`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Get the application\'s background.  User must have APPLICATION_DEFINITION[READ] permission. 
     * Get the application\'s background
     */
    async getApplicationBackgroundByApplicationId(requestParameters: GetApplicationBackgroundByApplicationIdRequest): Promise<Blob> {
        const response = await this.getApplicationBackgroundByApplicationIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get an application.  User must have the APPLICATION_DEFINITION[READ] permission. 
     * Get an application.
     */
    async getApplicationByApplicationIdRaw(requestParameters: GetApplicationByApplicationIdRequest): Promise<runtime.ApiResponse<Application>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getApplicationByApplicationId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
    }

    /**
     * Get an application.  User must have the APPLICATION_DEFINITION[READ] permission. 
     * Get an application.
     */
    async getApplicationByApplicationId(requestParameters: GetApplicationByApplicationIdRequest): Promise<Application> {
        const response = await this.getApplicationByApplicationIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a specific log of an application.  User must have the APPLICATION_LOG[READ] permission. 
     * Get a specific log of an application
     */
    async getApplicationLogByApplicationIdAndLogIdRaw(requestParameters: GetApplicationLogByApplicationIdAndLogIdRequest): Promise<runtime.ApiResponse<Log>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getApplicationLogByApplicationIdAndLogId.');
        }

        if (requestParameters.logId === null || requestParameters.logId === undefined) {
            throw new runtime.RequiredError('logId','Required parameter requestParameters.logId was null or undefined when calling getApplicationLogByApplicationIdAndLogId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.timestamp !== undefined) {
            queryParameters['timestamp'] = requestParameters.timestamp;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/logs/{logId}`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))).replace(`{${"logId"}}`, encodeURIComponent(String(requestParameters.logId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LogFromJSON(jsonValue));
    }

    /**
     * Get a specific log of an application.  User must have the APPLICATION_LOG[READ] permission. 
     * Get a specific log of an application
     */
    async getApplicationLogByApplicationIdAndLogId(requestParameters: GetApplicationLogByApplicationIdAndLogIdRequest): Promise<Log> {
        const response = await this.getApplicationLogByApplicationIdAndLogIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the application logs.  User must have the APPLICATION_LOG[READ] permission. 
     * Get Application logs
     */
    async getApplicationLogsRaw(requestParameters: GetApplicationLogsRequest): Promise<runtime.ApiResponse<LogsResponse>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getApplicationLogs.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.to !== undefined) {
            queryParameters['to'] = requestParameters.to;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.field !== undefined) {
            queryParameters['field'] = requestParameters.field;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/logs`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LogsResponseFromJSON(jsonValue));
    }

    /**
     * Get the application logs.  User must have the APPLICATION_LOG[READ] permission. 
     * Get Application logs
     */
    async getApplicationLogs(requestParameters: GetApplicationLogsRequest): Promise<LogsResponse> {
        const response = await this.getApplicationLogsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get an application member.  User must have the APPLICATION_MEMBER[READ] permission. 
     * Get an application member
     */
    async getApplicationMemberByApplicationIdAndMemberIdRaw(requestParameters: GetApplicationMemberByApplicationIdAndMemberIdRequest): Promise<runtime.ApiResponse<Member>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getApplicationMemberByApplicationIdAndMemberId.');
        }

        if (requestParameters.memberId === null || requestParameters.memberId === undefined) {
            throw new runtime.RequiredError('memberId','Required parameter requestParameters.memberId was null or undefined when calling getApplicationMemberByApplicationIdAndMemberId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/members/{memberId}`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))).replace(`{${"memberId"}}`, encodeURIComponent(String(requestParameters.memberId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MemberFromJSON(jsonValue));
    }

    /**
     * Get an application member.  User must have the APPLICATION_MEMBER[READ] permission. 
     * Get an application member
     */
    async getApplicationMemberByApplicationIdAndMemberId(requestParameters: GetApplicationMemberByApplicationIdAndMemberIdRequest): Promise<Member> {
        const response = await this.getApplicationMemberByApplicationIdAndMemberIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get an application metadata.  User must have the APPLICATION_METADATA[READ] permission. 
     * Get an application metadata
     */
    async getApplicationMetadataByApplicationIdAndMetadataIdRaw(requestParameters: GetApplicationMetadataByApplicationIdAndMetadataIdRequest): Promise<runtime.ApiResponse<ReferenceMetadata>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getApplicationMetadataByApplicationIdAndMetadataId.');
        }

        if (requestParameters.metadataId === null || requestParameters.metadataId === undefined) {
            throw new runtime.RequiredError('metadataId','Required parameter requestParameters.metadataId was null or undefined when calling getApplicationMetadataByApplicationIdAndMetadataId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/metadata/{metadataId}`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))).replace(`{${"metadataId"}}`, encodeURIComponent(String(requestParameters.metadataId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ReferenceMetadataFromJSON(jsonValue));
    }

    /**
     * Get an application metadata.  User must have the APPLICATION_METADATA[READ] permission. 
     * Get an application metadata
     */
    async getApplicationMetadataByApplicationIdAndMetadataId(requestParameters: GetApplicationMetadataByApplicationIdAndMetadataIdRequest): Promise<ReferenceMetadata> {
        const response = await this.getApplicationMetadataByApplicationIdAndMetadataIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the application\'s picture.  User must have APPLICATION_DEFINITION[READ] permission. 
     * Get the application\'s picture
     */
    async getApplicationPictureByApplicationIdRaw(requestParameters: GetApplicationPictureByApplicationIdRequest): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getApplicationPictureByApplicationId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/picture`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Get the application\'s picture.  User must have APPLICATION_DEFINITION[READ] permission. 
     * Get the application\'s picture
     */
    async getApplicationPictureByApplicationId(requestParameters: GetApplicationPictureByApplicationIdRequest): Promise<Blob> {
        const response = await this.getApplicationPictureByApplicationIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get application type. 
     * Get the application type configuration.
     */
    async getApplicationTypeRaw(requestParameters: GetApplicationTypeRequest): Promise<runtime.ApiResponse<ApplicationType>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getApplicationType.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/configuration`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationTypeFromJSON(jsonValue));
    }

    /**
     * Get application type. 
     * Get the application type configuration.
     */
    async getApplicationType(requestParameters: GetApplicationTypeRequest): Promise<ApplicationType> {
        const response = await this.getApplicationTypeRaw(requestParameters);
        return await response.value();
    }

    /**
     * List all the applications accessible to authenticated user.  User must have MANAGEMENT_APPLICATION[READ] and PORTAL_APPLICATION[READ] permission. 
     * List all the applications accessible to authenticated user. Default order is by *name* ASC.
     */
    async getApplicationsRaw(requestParameters: GetApplicationsRequest): Promise<runtime.ApiResponse<ApplicationsResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.forSubscription !== undefined) {
            queryParameters['forSubscription'] = requestParameters.forSubscription;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationsResponseFromJSON(jsonValue));
    }

    /**
     * List all the applications accessible to authenticated user.  User must have MANAGEMENT_APPLICATION[READ] and PORTAL_APPLICATION[READ] permission. 
     * List all the applications accessible to authenticated user. Default order is by *name* ASC.
     */
    async getApplications(requestParameters: GetApplicationsRequest): Promise<ApplicationsResponse> {
        const response = await this.getApplicationsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get application\'s hooks that can be used in the portal. 
     * Get the application\'s hooks list.
     */
    async getHooksRaw(): Promise<runtime.ApiResponse<Array<Hook>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/hooks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(HookFromJSON));
    }

    /**
     * Get application\'s hooks that can be used in the portal. 
     * Get the application\'s hooks list.
     */
    async getHooks(): Promise<Array<Hook>> {
        const response = await this.getHooksRaw();
        return await response.value();
    }

    /**
     * List application members.  User must have the APPLICATION_MEMBER[READ] permission. 
     * List application members
     */
    async getMembersByApplicationIdRaw(requestParameters: GetMembersByApplicationIdRequest): Promise<runtime.ApiResponse<MembersResponse>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getMembersByApplicationId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/members`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MembersResponseFromJSON(jsonValue));
    }

    /**
     * List application members.  User must have the APPLICATION_MEMBER[READ] permission. 
     * List application members
     */
    async getMembersByApplicationId(requestParameters: GetMembersByApplicationIdRequest): Promise<MembersResponse> {
        const response = await this.getMembersByApplicationIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * List application metadata.  User must have the APPLICATION_METADATA[READ] permission. 
     * List application metadata
     */
    async getMetadataByApplicationIdRaw(requestParameters: GetMetadataByApplicationIdRequest): Promise<runtime.ApiResponse<ReferenceMetadataResponse>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getMetadataByApplicationId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/metadata`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ReferenceMetadataResponseFromJSON(jsonValue));
    }

    /**
     * List application metadata.  User must have the APPLICATION_METADATA[READ] permission. 
     * List application metadata
     */
    async getMetadataByApplicationId(requestParameters: GetMetadataByApplicationIdRequest): Promise<ReferenceMetadataResponse> {
        const response = await this.getMetadataByApplicationIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get application notifications.  User must have APPLICATION_NOTIFICATION[READ] permission to get notifications. 
     * Get application notifications
     */
    async getNotificationsByApplicationIdRaw(requestParameters: GetNotificationsByApplicationIdRequest): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getNotificationsByApplicationId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/notifications`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get application notifications.  User must have APPLICATION_NOTIFICATION[READ] permission to get notifications. 
     * Get application notifications
     */
    async getNotificationsByApplicationId(requestParameters: GetNotificationsByApplicationIdRequest): Promise<Array<string>> {
        const response = await this.getNotificationsByApplicationIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Lists API that current user is allowed to access. May be filtered by status. Ordered by nimber of hits.  This application has to be accessible by the current user, otherwise a 404 will be returned. 
     * List APIs that subscribed with an application
     */
    async getSubscriberApisByApplicationIdRaw(requestParameters: GetSubscriberApisByApplicationIdRequest): Promise<runtime.ApiResponse<ApisResponse>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling getSubscriberApisByApplicationId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.statuses) {
            queryParameters['statuses'] = requestParameters.statuses;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/subscribers`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApisResponseFromJSON(jsonValue));
    }

    /**
     * Lists API that current user is allowed to access. May be filtered by status. Ordered by nimber of hits.  This application has to be accessible by the current user, otherwise a 404 will be returned. 
     * List APIs that subscribed with an application
     */
    async getSubscriberApisByApplicationId(requestParameters: GetSubscriberApisByApplicationIdRequest): Promise<ApisResponse> {
        const response = await this.getSubscriberApisByApplicationIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Renew the client secret for an OAuth2 application.  User must have the APPLICATION_DEFINITION[UPDATE] permission. 
     * Renew the client secret for an OAuth2 application
     */
    async renewApplicationSecretRaw(requestParameters: RenewApplicationSecretRequest): Promise<runtime.ApiResponse<Application>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling renewApplicationSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/_renew_secret`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
    }

    /**
     * Renew the client secret for an OAuth2 application.  User must have the APPLICATION_DEFINITION[UPDATE] permission. 
     * Renew the client secret for an OAuth2 application
     */
    async renewApplicationSecret(requestParameters: RenewApplicationSecretRequest): Promise<Application> {
        const response = await this.renewApplicationSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * Renew the shared api key of on application. The application must have the ApiKeyMode set to SHARED User must have APPLICATION_SUBSCRIPTION[UPDATE] permission. 
     * Renew the shared api key of an application.
     */
    async renewSharedKeyRaw(requestParameters: RenewSharedKeyRequest): Promise<runtime.ApiResponse<Key>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling renewSharedKey.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/keys/_renew`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => KeyFromJSON(jsonValue));
    }

    /**
     * Renew the shared api key of on application. The application must have the ApiKeyMode set to SHARED User must have APPLICATION_SUBSCRIPTION[UPDATE] permission. 
     * Renew the shared api key of an application.
     */
    async renewSharedKey(requestParameters: RenewSharedKeyRequest): Promise<Key> {
        const response = await this.renewSharedKeyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Revoke the shared api key of on application. The application must have the ApiKeyMode set to SHARED User must have APPLICATION_SUBSCRIPTION[UPDATE] permission. 
     * Revoke the shared api key of an application.
     */
    async revokeSharedKeyRaw(requestParameters: RevokeSharedKeyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling revokeSharedKey.');
        }

        if (requestParameters.apiKey === null || requestParameters.apiKey === undefined) {
            throw new runtime.RequiredError('apiKey','Required parameter requestParameters.apiKey was null or undefined when calling revokeSharedKey.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/keys/{apiKey}/_revoke`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))).replace(`{${"apiKey"}}`, encodeURIComponent(String(requestParameters.apiKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revoke the shared api key of on application. The application must have the ApiKeyMode set to SHARED User must have APPLICATION_SUBSCRIPTION[UPDATE] permission. 
     * Revoke the shared api key of an application.
     */
    async revokeSharedKey(requestParameters: RevokeSharedKeyRequest): Promise<void> {
        await this.revokeSharedKeyRaw(requestParameters);
    }

    /**
     * Transfer the ownership of the application.  User must have the APPLICATION_MEMBER[UPDATE] permission. 
     * Transfer the ownership of the application
     */
    async transferMemberOwnershipRaw(requestParameters: TransferMemberOwnershipRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling transferMemberOwnership.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/members/_transfer_ownership`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TransferOwnershipInputToJSON(requestParameters.transferOwnershipInput),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Transfer the ownership of the application.  User must have the APPLICATION_MEMBER[UPDATE] permission. 
     * Transfer the ownership of the application
     */
    async transferMemberOwnership(requestParameters: TransferMemberOwnershipRequest): Promise<void> {
        await this.transferMemberOwnershipRaw(requestParameters);
    }

    /**
     * Update alert for an application.  User must have APPLICATION_ALERT[UPDATE] permission to update alerts. 
     * Update alert for an application.
     */
    async updateAlertRaw(requestParameters: UpdateAlertRequest): Promise<runtime.ApiResponse<Alert>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling updateAlert.');
        }

        if (requestParameters.alertId === null || requestParameters.alertId === undefined) {
            throw new runtime.RequiredError('alertId','Required parameter requestParameters.alertId was null or undefined when calling updateAlert.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/alerts/{alertId}`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))).replace(`{${"alertId"}}`, encodeURIComponent(String(requestParameters.alertId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AlertInputToJSON(requestParameters.alertInput),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertFromJSON(jsonValue));
    }

    /**
     * Update alert for an application.  User must have APPLICATION_ALERT[UPDATE] permission to update alerts. 
     * Update alert for an application.
     */
    async updateAlert(requestParameters: UpdateAlertRequest): Promise<Alert> {
        const response = await this.updateAlertRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an application.  User must have APPLICATION_DEFINITION[UPDATE] permission. 
     * Update an application.
     */
    async updateApplicationByApplicationIdRaw(requestParameters: UpdateApplicationByApplicationIdRequest): Promise<runtime.ApiResponse<Application>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling updateApplicationByApplicationId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ApplicationToJSON(requestParameters.application),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
    }

    /**
     * Update an application.  User must have APPLICATION_DEFINITION[UPDATE] permission. 
     * Update an application.
     */
    async updateApplicationByApplicationId(requestParameters: UpdateApplicationByApplicationIdRequest): Promise<Application> {
        const response = await this.updateApplicationByApplicationIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an application member.  User must have the APPLICATION_MEMBER[UPDATE] permission. 
     * Update an application member.
     */
    async updateApplicationMemberByApplicationIdAndMemberIdRaw(requestParameters: UpdateApplicationMemberByApplicationIdAndMemberIdRequest): Promise<runtime.ApiResponse<Member>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling updateApplicationMemberByApplicationIdAndMemberId.');
        }

        if (requestParameters.memberId === null || requestParameters.memberId === undefined) {
            throw new runtime.RequiredError('memberId','Required parameter requestParameters.memberId was null or undefined when calling updateApplicationMemberByApplicationIdAndMemberId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/members/{memberId}`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))).replace(`{${"memberId"}}`, encodeURIComponent(String(requestParameters.memberId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MemberInputToJSON(requestParameters.memberInput),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MemberFromJSON(jsonValue));
    }

    /**
     * Update an application member.  User must have the APPLICATION_MEMBER[UPDATE] permission. 
     * Update an application member.
     */
    async updateApplicationMemberByApplicationIdAndMemberId(requestParameters: UpdateApplicationMemberByApplicationIdAndMemberIdRequest): Promise<Member> {
        const response = await this.updateApplicationMemberByApplicationIdAndMemberIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an application metadata.  User must have the APPLICATION_METADATA[UPDATE] permission. 
     * Update an application metadata.
     */
    async updateApplicationMetadataByApplicationIdAndMetadataIdRaw(requestParameters: UpdateApplicationMetadataByApplicationIdAndMetadataIdRequest): Promise<runtime.ApiResponse<ReferenceMetadata>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling updateApplicationMetadataByApplicationIdAndMetadataId.');
        }

        if (requestParameters.metadataId === null || requestParameters.metadataId === undefined) {
            throw new runtime.RequiredError('metadataId','Required parameter requestParameters.metadataId was null or undefined when calling updateApplicationMetadataByApplicationIdAndMetadataId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/metadata/{metadataId}`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))).replace(`{${"metadataId"}}`, encodeURIComponent(String(requestParameters.metadataId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ReferenceMetadataInputToJSON(requestParameters.referenceMetadataInput),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ReferenceMetadataFromJSON(jsonValue));
    }

    /**
     * Update an application metadata.  User must have the APPLICATION_METADATA[UPDATE] permission. 
     * Update an application metadata.
     */
    async updateApplicationMetadataByApplicationIdAndMetadataId(requestParameters: UpdateApplicationMetadataByApplicationIdAndMetadataIdRequest): Promise<ReferenceMetadata> {
        const response = await this.updateApplicationMetadataByApplicationIdAndMetadataIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update notifications for an application.  User must have APPLICATION_NOTIFICATION[UPDATE] permission to update notifications. 
     * Update notifications for an application.
     */
    async updateApplicationNotificationsRaw(requestParameters: UpdateApplicationNotificationsRequest): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling updateApplicationNotifications.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/applications/{applicationId}/notifications`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: NotificationInputToJSON(requestParameters.notificationInput),
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Update notifications for an application.  User must have APPLICATION_NOTIFICATION[UPDATE] permission to update notifications. 
     * Update notifications for an application.
     */
    async updateApplicationNotifications(requestParameters: UpdateApplicationNotificationsRequest): Promise<Array<string>> {
        const response = await this.updateApplicationNotificationsRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum ExportApplicationLogsByApplicationIdOrderEnum {
    ASC = 'ASC',
    DESC = 'DESC'
}
/**
    * @export
    * @enum {string}
    */
export enum GetApplicationAnalyticsTypeEnum {
    GROUPBY = 'GROUP_BY',
    DATEHISTO = 'DATE_HISTO',
    COUNT = 'COUNT',
    STATS = 'STATS'
}
/**
    * @export
    * @enum {string}
    */
export enum GetApplicationLogsOrderEnum {
    ASC = 'ASC',
    DESC = 'DESC'
}
/**
    * @export
    * @enum {string}
    */
export enum GetSubscriberApisByApplicationIdStatusesEnum {
    ACCEPTED = 'ACCEPTED',
    CLOSED = 'CLOSED',
    PAUSED = 'PAUSED',
    PENDING = 'PENDING',
    REJECTED = 'REJECTED'
}
